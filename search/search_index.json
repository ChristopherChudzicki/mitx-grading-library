{
    "docs": [
        {
            "location": "/", 
            "text": "MITx Grading Library Documentation\n\n\nThis documentation describes how to use the grading library. In particular, it goes through the syntax required to construct each of the different types of graders.\n\n\nFor information on installation and how to use the library in edX, see \nhere\n.\n\n\nOverview\n\n\nThe basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general.\n\n\nUsing Grading Classes\n\n\nAll grading classes are instantiated by calling them. Here, \nGradingClass\n is a generic grading class (\nGradingClass\n does not actually exist).\n\n\ngrader = GradingClass(options)\n\n\n\n\nThe options provided to a grading class may be passed in directly, as\n\n\ngrader = GradingClass(name='value')\n\n\n\n\nYou can also pass in a configuration dictionary. This may be helpful if using the same configuration for multiple problems.\n\n\noptions = {'name': 'value'}\ngrader = GradingClass(options)\n\n\n\n\nYou cannot 'mix and match' these two options. If a configuration dictionary is supplied, any keyword arguments are ignored.\n\n\nOptions\n\n\nThe options passed to a grading class undergo extensive validation and graders will throw\nerrors if instantiated with invalid options.\n\n\nA few error messages serve only as warnings (e.g., that you are attempting to override a default constant like \npi\n). These warning errors can be suppressed by setting\n\n\ngrader = GradingClass(suppress_warnings=True)\n\n\n\n\nEvery grading class also has a debug option. By default, \ndebug=False\n. To receive debug information from a given grader, specify \ndebug=True\n. Some graders will provide more debug information than others.\n\n\ngrader = GradingClass(debug=True)\n\n\n\n\nAll other options are specific to the grading class in question.\n\n\nGrading Classes\n\n\nGrading classes generally fall into two categories: single-input graders and multi-input graders.\n\n\nAll graders that grade a single input are built on a framework we call an ItemGrader. We recommend understanding how ItemGraders work before diving into more specifics. We provide a number of graders built off ItemGrader. A special type of ItemGrader is SingleListGrader, which lets you grade a delimiter-separated list of inputs in a single response.\n\n\nMulti-input graders that are just composed of single-input graders working in concert can be handled by the general ListGrader class. At this stage, ListGrader is the only multi-input grader included in the library, although plugins can be used to construct further examples.\n\n\n\n\nItemGrader\n\n\nStringGrader\n\n\nFormulaGrader and NumericalGrader\n\n\nSingleListGrader\n\n\nListGrader\n\n\n\n\nPlugins\n\n\nAny .py file stored in the \nplugins\n folder will be automatically loaded. All variables in the \nall\n list will be made available when doing \nfrom mitxgraders import *\n. See \ntemplate.py\n for an example.\n\n\nYou can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from \nstringgrader.py\n, renaming the class, and building a simple plugin based on \nStringGrader\n.\n\n\nWe are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through \ngithub\n. We are also willing to consider incorporating good plugins into the library itself.", 
            "title": "Home"
        }, 
        {
            "location": "/#mitx-grading-library-documentation", 
            "text": "This documentation describes how to use the grading library. In particular, it goes through the syntax required to construct each of the different types of graders.  For information on installation and how to use the library in edX, see  here .", 
            "title": "MITx Grading Library Documentation"
        }, 
        {
            "location": "/#overview", 
            "text": "The basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general.", 
            "title": "Overview"
        }, 
        {
            "location": "/#using-grading-classes", 
            "text": "All grading classes are instantiated by calling them. Here,  GradingClass  is a generic grading class ( GradingClass  does not actually exist).  grader = GradingClass(options)  The options provided to a grading class may be passed in directly, as  grader = GradingClass(name='value')  You can also pass in a configuration dictionary. This may be helpful if using the same configuration for multiple problems.  options = {'name': 'value'}\ngrader = GradingClass(options)  You cannot 'mix and match' these two options. If a configuration dictionary is supplied, any keyword arguments are ignored.", 
            "title": "Using Grading Classes"
        }, 
        {
            "location": "/#options", 
            "text": "The options passed to a grading class undergo extensive validation and graders will throw\nerrors if instantiated with invalid options.  A few error messages serve only as warnings (e.g., that you are attempting to override a default constant like  pi ). These warning errors can be suppressed by setting  grader = GradingClass(suppress_warnings=True)  Every grading class also has a debug option. By default,  debug=False . To receive debug information from a given grader, specify  debug=True . Some graders will provide more debug information than others.  grader = GradingClass(debug=True)  All other options are specific to the grading class in question.", 
            "title": "Options"
        }, 
        {
            "location": "/#grading-classes", 
            "text": "Grading classes generally fall into two categories: single-input graders and multi-input graders.  All graders that grade a single input are built on a framework we call an ItemGrader. We recommend understanding how ItemGraders work before diving into more specifics. We provide a number of graders built off ItemGrader. A special type of ItemGrader is SingleListGrader, which lets you grade a delimiter-separated list of inputs in a single response.  Multi-input graders that are just composed of single-input graders working in concert can be handled by the general ListGrader class. At this stage, ListGrader is the only multi-input grader included in the library, although plugins can be used to construct further examples.   ItemGrader  StringGrader  FormulaGrader and NumericalGrader  SingleListGrader  ListGrader", 
            "title": "Grading Classes"
        }, 
        {
            "location": "/#plugins", 
            "text": "Any .py file stored in the  plugins  folder will be automatically loaded. All variables in the  all  list will be made available when doing  from mitxgraders import * . See  template.py  for an example.  You can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from  stringgrader.py , renaming the class, and building a simple plugin based on  StringGrader .  We are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through  github . We are also willing to consider incorporating good plugins into the library itself.", 
            "title": "Plugins"
        }, 
        {
            "location": "/item_grader/", 
            "text": "ItemGrader\n\n\nWhen an individual input needs to be graded, it is graded by an item grader. All item graders work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use \nStringGrader\n as an example of how to use a generic ItemGrader. You cannot use a generic ItemGrader by itself.\n\n\ngrader = StringGrader(\n    answers='cat',\n    wrong_msg='Try again!'\n)\n\n\n\n\nThe \nanswers\n can be used to specify correct answers, specific feedback messages, and to assign partial credit. The \nanswers\n key accepts a few formats:\n\n\n\n\nA single dictionary can be used to specify an answer, feedback, correctness, and partial credit:\n\n\n\n\ngrader = StringGrader(\n    answers={'expect': 'zebra', 'ok': True, 'grade_decimal': 1, 'msg': 'Yay!'},\n    wrong_msg='Try again!'\n)\n\n\n\n\nThe answers dictionary keys are:\n  - \n'expect'\n (required): compared against student answer. Most ItemGraders use strings to specify the \n'expect'\n value.\n  - \n'grade_decimal'\n (a number between \n0\n and \n1\n): The partial credit associated with this answer; default value is \n1\n.\n  - \n'ok'\n (\nTrue\n, \nFalse\n, or \n'partial'\n): The answer's correctness; determines icon used by edX. The default value is inferred from \ngrade_decimal\n.\n  - \n'msg'\n (string): A feedback message associated with this answer.\n\n\n\n\nA single \n'expect'\n value: can be used to specify the correct answer. For example,\n\n\n\n\ngrader = StringGrader(\n    answers='cat',\n    # Equivalent to:\n    # answers={'expect': 'cat', 'msg': '', 'grade_decimal': 1, 'ok': True}\n    wrong_msg='Try again!'\n)\n\n\n\n\nAgain, most ItemGraders use strings to store \n'expect'\n values.\n\n\n\n\nA tuple of dictionaries or strings:\n\n\n\n\ngrader = StringGrader(\n    answers=(\n        # the correct answer\n        'wolf',\n        # an alternative correct answer\n        'canis lupus',\n        # a partially correct answer\n        {'expect': 'dog', 'grade_decimal': 0.5, 'msg': 'No, not dog!'},\n        # a wrong answer with specific feedback\n        {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'No, not unicorn!'}\n    ),\n    wrong_msg='Try again!'\n)\n\n\n\n\nInternally, the ItemGrader converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student.\n\n\nThe \nwrong_msg\n is only displayed if the score is zero, and there are no other messages.\n\n\nOption Listing\n\n\nHere is the full list of options specific to an \nItemGrader\n.\n\n\ngrader = ItemGrader(\n    answers=answer or tuple of answers,\n    wrong_msg=string (default '')\n)\n\n\n\n\n\n\nHome", 
            "title": "ItemGrader"
        }, 
        {
            "location": "/item_grader/#itemgrader", 
            "text": "When an individual input needs to be graded, it is graded by an item grader. All item graders work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use  StringGrader  as an example of how to use a generic ItemGrader. You cannot use a generic ItemGrader by itself.  grader = StringGrader(\n    answers='cat',\n    wrong_msg='Try again!'\n)  The  answers  can be used to specify correct answers, specific feedback messages, and to assign partial credit. The  answers  key accepts a few formats:   A single dictionary can be used to specify an answer, feedback, correctness, and partial credit:   grader = StringGrader(\n    answers={'expect': 'zebra', 'ok': True, 'grade_decimal': 1, 'msg': 'Yay!'},\n    wrong_msg='Try again!'\n)  The answers dictionary keys are:\n  -  'expect'  (required): compared against student answer. Most ItemGraders use strings to specify the  'expect'  value.\n  -  'grade_decimal'  (a number between  0  and  1 ): The partial credit associated with this answer; default value is  1 .\n  -  'ok'  ( True ,  False , or  'partial' ): The answer's correctness; determines icon used by edX. The default value is inferred from  grade_decimal .\n  -  'msg'  (string): A feedback message associated with this answer.   A single  'expect'  value: can be used to specify the correct answer. For example,   grader = StringGrader(\n    answers='cat',\n    # Equivalent to:\n    # answers={'expect': 'cat', 'msg': '', 'grade_decimal': 1, 'ok': True}\n    wrong_msg='Try again!'\n)  Again, most ItemGraders use strings to store  'expect'  values.   A tuple of dictionaries or strings:   grader = StringGrader(\n    answers=(\n        # the correct answer\n        'wolf',\n        # an alternative correct answer\n        'canis lupus',\n        # a partially correct answer\n        {'expect': 'dog', 'grade_decimal': 0.5, 'msg': 'No, not dog!'},\n        # a wrong answer with specific feedback\n        {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'No, not unicorn!'}\n    ),\n    wrong_msg='Try again!'\n)  Internally, the ItemGrader converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student.  The  wrong_msg  is only displayed if the score is zero, and there are no other messages.", 
            "title": "ItemGrader"
        }, 
        {
            "location": "/item_grader/#option-listing", 
            "text": "Here is the full list of options specific to an  ItemGrader .  grader = ItemGrader(\n    answers=answer or tuple of answers,\n    wrong_msg=string (default '')\n)   Home", 
            "title": "Option Listing"
        }, 
        {
            "location": "/string_grader/", 
            "text": "StringGrader\n\n\nThe StringGrader class does a letter-for-letter comparison of the student's answer with the expected answer. It is the simplest grading class, both in code and in usage.\n\n\nTo use a StringGrader, simply pass in the set of answers you want to grade, as described in the \nItemGrader documentation\n.\n\n\ngrader = StringGrader(\n    answers='cat'\n)\n\n\n\n\nThis will accept the answer of \ncat\n, but not \nCAT\n or \nCat\n, as grading is case-sensitive by default.\n\n\nCase Sensitive\n\n\nTo perform case-insensitive grading, pass in the appropriate flag as follows.\n\n\ngrader = StringGrader(\n    answers='Cat',\n    case_sensitive=False\n)\n\n\n\n\nThis will accept \nCat\n, \ncat\n and \nCAT\n. By default, \ncase_sensitive=True\n.\n\n\nStripping Input\n\n\nLeading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip.\n\n\ngrader = StringGrader(\n    answers='cat',\n    strip=False\n)\n\n\n\n\nThis will accept \ncat\n, but will reject answers with leading or trailing spaces. By default, \nstrip=True\n.\n\n\nOption Listing\n\n\nHere is the full list of options specific to a \nStringGrader\n.\n\n\ngrader = SingleListGrader(\n    case_sensitive=bool (default True),\n    strip=bool (default False)\n)\n\n\n\n\n\n\nHome", 
            "title": "StringGrader"
        }, 
        {
            "location": "/string_grader/#stringgrader", 
            "text": "The StringGrader class does a letter-for-letter comparison of the student's answer with the expected answer. It is the simplest grading class, both in code and in usage.  To use a StringGrader, simply pass in the set of answers you want to grade, as described in the  ItemGrader documentation .  grader = StringGrader(\n    answers='cat'\n)  This will accept the answer of  cat , but not  CAT  or  Cat , as grading is case-sensitive by default.", 
            "title": "StringGrader"
        }, 
        {
            "location": "/string_grader/#case-sensitive", 
            "text": "To perform case-insensitive grading, pass in the appropriate flag as follows.  grader = StringGrader(\n    answers='Cat',\n    case_sensitive=False\n)  This will accept  Cat ,  cat  and  CAT . By default,  case_sensitive=True .", 
            "title": "Case Sensitive"
        }, 
        {
            "location": "/string_grader/#stripping-input", 
            "text": "Leading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip.  grader = StringGrader(\n    answers='cat',\n    strip=False\n)  This will accept  cat , but will reject answers with leading or trailing spaces. By default,  strip=True .", 
            "title": "Stripping Input"
        }, 
        {
            "location": "/string_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  StringGrader .  grader = SingleListGrader(\n    case_sensitive=bool (default True),\n    strip=bool (default False)\n)   Home", 
            "title": "Option Listing"
        }, 
        {
            "location": "/grading_math/formula_grader/", 
            "text": "FormulaGrader\n\n\nFormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's \nformularesponse /\n tag, but with much more versatility.\n\n\nAll whitespace is stripped from formulas that are entered. So, \n1 + x ^ 2\n is equivalent to \n1+x^2\n.\n\n\nVariables and Sampling\n\n\nFormulaGrader grades a formula by numerical sampling. That is, random values are  assigned to each of the unknown variables and unknown functions, then the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.\n\n\nVariables are configured by including a list of strings of each variable name as follows.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2+y',\n    variables=['x', 'y']\n)\n\n\n\n\nNote that the \nanswers\n parameter follows all of the usual allowances from ItemGrader.\n\n\nThe variables need to have numbers randomly assigned to them. Each is sampled from a \nsampling set\n, which is RealInterval() by default (random numbers from 1 to 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the \nsample_from\n key.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2+y+z/2',\n    variables=['x', 'y', 'z'],\n    sample_from={\n        'x': ComplexRectangle(),\n        'y': [2, 6],\n        'z': (1, 3, 4, 8)\n    }\n)\n\n\n\n\nThe \nsample_from\n key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.\n\n\nNumbered Variables\n\n\nYou can also specify special variables that are numbered. For example, if you specify that \na\n is a numbered variable, students can include \na_{0}\n, \na_{5}\n, \na_{-2}\n, etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.\n\n\ngrader = FormulaGrader(\n    answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n    variables=['x'],\n    numbered_vars=['a'],\n    sample_from={\n        'x': [-5, 5],\n        'a': [-10, 10]\n    }\n)\n\n\n\n\nIf you have a variable name that would clash with a numbered variable (say, you defined \na_{0}\n and also a numbered variable \na\n), then the specific variable has precedence.\n\n\nSamples and Failable Evaluations\n\n\nTo control the number of samples that are checked to ensure correctness, you can modify the \nsamples\n key.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10\n)\n\n\n\n\nThe default for \nsamples\n is 5.\n\n\nYou may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set \nfailable_evals\n. This should be used very sparingly!\n\n\ngrader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10,\n    failable_evals=1\n)\n\n\n\n\nFunctions\n\n\nBy default, a large array of mathematical functions are available for use. See the full list \nhere\n. Note that functions for manipulating complex variables are available, which allows you to grade complex expressions. In the following example, \nz*z\n is recognized to be different from \nabs(z)^2\n.\n\n\ngrader = FormulaGrader(\n    answers='abs(z)^2',\n    variables=['z'],\n    sample_from={\n        'z': ComplexRectangle()\n    }\n)\n\n\n\n\nUser Functions\n\n\nYou can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the \nuser_functions\n key as follows.\n\n\ngrader = FormulaGrader(\n    answers='x*x',\n    variables=['x'],\n    user_functions={'f': lambda x: x*x}\n)\n\n\n\n\nThis defines a function \nf(x) = x^2\n. User-defined function names must start with a letter, and can use numbers and underscores, such as \nmy_func2\n. They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg, \nf''\n. Be careful about using quotation marks appropriately when using primes in function names!\n\n\ngrader = FormulaGrader(\n    answers=\nf''(x)\n,\n    variables=['x'],\n    user_functions={\nf''\n: lambda x: x*x}\n)\n\n\n\n\nYou can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.\n\n\ngrader = FormulaGrader(\n    answers=\nf(x)\n,\n    variables=['x'],\n    user_functions={\nf\n: [np.sin, np.cos]}\n)\n\n\n\n\nEach time this formula is checked, the function \nf\n will be sampled from the list of available functions.\n\n\nYou can also specify a random well-behaved function by using the RandomFunction() sampling set.\n\n\ngrader = FormulaGrader(\n    answers=\nf''(x) + omega^2*f(x)\n,\n    variables=['x', 'omega'],\n    user_functions={\n        \nf\n: RandomFunction(),\n        \nf''\n: RandomFunction()\n    }\n)\n\n\n\n\nThis allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example.\n\n\nConstants\n\n\nBy default, four constants are defined: \ne\n, \npi\n, and \ni=j=sqrt(-1)\n. You can define new constants by passing in a dictionary to \nuser_constants\n as follows.\n\n\ngrader = FormulaGrader(\n    answers='1/sqrt(1-v^2/c^2)',\n    variables=['v'],\n    user_constants={\n        'c': 3e8\n    }\n)\n\n\n\n\nConstants are like variables that only ever have one value.\n\n\nOverriding Default Functions and Constants\n\n\nYou can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with \nsuppress_warnings=True\n. The grader\n\n\ngrader = FormulaGrader(\n    answers='x^2',\n    variables=['x'],\n    user_functions={'sin': lambda x: x*x},\n)\n\n\n\n\nwill raise an error\n\n\n\n\nConfigError: Warning: 'user_functions' contains entries '['sin']' which will override default values. If you intend to override to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.\n\n\n\n\nThe error can be suppressed by setting \nsuppress_warnings=True\n.\n\n\nRestricting Student Input\n\n\nFor some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand \nsin(2*theta)\n, then you don't want students to be able to just write \nsin(2*theta)\n and be graded correct.\n\n\nFormulaGrader offers a few ways to restrict what sort of answers will be marked correct.\n\n\nForbidden Strings\n\n\nYou can forbid students from entering certain strings using the \nforbidden_strings\n key:\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n    forbidden_message=\nYour answer should only use trigonometric functions acting on theta, not multiples of theta\n\n)\n\n\n\n\nIf a student tries to use one of these strings, then they receive the \nforbidden_message\n, without giving away what the forbidden string is. We recommend using this sparingly, as students will find it confusing. The default \nforbidden_message\n is \"Invalid Input: This particular answer is forbidden\".\n\n\nForbidden strings and student answers are stripped of whitespace before being compared. Thus, if \nx + y\n is forbidden, then answers containing \nx+y\n or \nx   +   y\n will be rejected.\n\n\nBlacklists and Whitelists\n\n\nYou can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example, \nsin\n is disallowed in correct answers.\n\n\ngrader = FormulaGrader(\n    answers='sqrt(1 - cos(x)^2)',\n    variables=['x'],\n    sample_from={'x': [0, np.pi]},\n    blacklist=['sin']\n)\n\n\n\n\nIf you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos.\n\n\ngrader = FormulaGrader(\n    answers='sin(x)/cos(x)',\n    variables=['x'],\n    whitelist=['sin', 'cos']\n)\n\n\n\n\nIf you want to exclude all functions, use \nwhitelist=[None]\n:\n\n\ngrader = FormulaGrader(\n    answers='pi/2-x',\n    variables=['x'],\n    whitelist=[None] # no functions are allowed\n)\n\n\n\n\nYou cannot use a whitelist and a blacklist at the same time.\n\n\nRequired Functions\n\n\nYou can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    required_functions=['sin', 'cos']\n)\n\n\n\n\nTolerance\n\n\nStudent inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg, \n0.1\n) or a percentage (eg, \n\"0.01%\"\n, which is the default tolerance).  Tolerances must be nonnegative numbers or percentages.\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    tolerance=0.00001\n)\n\n\n\n\nTolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.\n\n\nCase Sensitive Input\n\n\nAll expressions are treated in a case sensitive manner. This means that variables \nm\n and \nM\n are distinct variables. Prior to version 1.1, we had a case-insensitive option available. However, this option is now deprecated, as it was causing issues in the codebase, nobody was using it (that we know of), and the majority of languages are case-sensitive anway.\n\n\nSuffixes\n\n\nNumbers with a % at the end will be treated as percentages, and converted to the appropriate decimals.\n\n\nedX also defines a number of metric suffixes (k, M, G, T, m, u, n, and p) that modify a number appropriately. However, in our experience, these metric suffixes lead to more confusion than use. For example, \n2M\n, which one would expect should be rejected as an error when \n2*M\n was intended, is accepted by edX, interpreted as \n2*10^6\n, marked incorrect, and eats a student's attempt. Similarly for all of the other metric suffixes.\n\n\nWe have therefore made the decision to disable metric suffixes by default. If you want to enable them, you can do so using the following.\n\n\ngrader = FormulaGrader(\n    answers='2*m',\n    variables=['m'],\n    metric_suffixes=True\n)\n\n\n\n\nWe strongly recommend \nnot\n doing this when using the following variable names: k, M, G, T, m, u, n, and p.\n\n\nComparer Functions\n\n\nBy default, FormulaGrader compares the numerically sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. For example, if grading angles in degrees, it may be useful to compare formulas modulo 360.\n\n\nTo use an alternate comparer, specify the \nanswers\n key as a dictionary with keys \ncomparer\n and \ncomparer_params\n rather than a single string. For example, to compare formulas modulo 360:\n\n\ndef is_coterminal(comparer_params_evals, student_eval, utils):\n    answer = comparer_params_evals[0]\n    reduced = student_eval % (360)\n    return utils.within_tolerance(answer, reduced)\n\ngrader = FormulaGrader(\n    answers={\n        'comparer': is_coterminal,\n        'comparer_params': ['b^2/a'],\n    },\n    variables=['a', 'b'],\n    tolerance='1%'\n)\n\n\n\n\nThis grader would accept \n'b^2/a'\n as well as \n'b^2/a + 360'\n, \n'b^2/a + 720'\n, etc.\n\n\nIn the grader configuration, \ncomparer_params\n is a list of strings that are numerically evaluated and passed to the comparer function. The \ncomparer\n function is a user-specified function with signature \ncomparer(comparer_params_evals, student_eval, utils)\n. When \nFormulaGrader\n calls the comparer function, \ncomparer\n the argument values are:\n- \ncomparer_params_evals\n: The \ncomparer_params\n list, numerically evaluated according to variable and function sampling.\n- \nstudent_eval\n: The student's input, numerically evaluated according to variable and function sampling\n- \nutils\n: A convenience object that may be helpful when writing custom comparer functions. Has properties:\n  - \nutils.tolerance\n: The tolerance specified in grader configuration, \n0.01%\n by default\n  - \nutils.within_tolerance:\n A function with signature \nwithin_tolerance(x, y)\n which checks that \ny\n is within specified tolerance of \nx\n. Can handle scalars, vectors, and matrices. If tolerance was specified as a percentage, then checks that \n|x-y| \n tolerance * x\n.\n\n\nOther Improvements\n\n\nWe have made a number of other improvements over the edX formula graders, including:\n\n\n\n\nSquare roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like \nsqrt(x-1)\n or \n(x-1)^0.5\n always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.\n\n\nOur parser uses a parsing cache, and hence runs much more efficiently than the edX graders.\n\n\nIf students input an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.\n\n\nWhen students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.\n\n\nSimilarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.\n\n\nIf an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the \ndebug\n flag to True, and a more technical message will usually be displayed.\n\n\nFull sampling details are included when the \ndebug\n flag is set to True.\n\n\n\n\nEnhancements to the AsciiMath renderer (the preview that students see when using \ntextline\n inputs) are available using our \nAsciiMath renderer definitions\n.\n\n\n\n\n\n\nHome", 
            "title": "FormulaGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#formulagrader", 
            "text": "FormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's  formularesponse /  tag, but with much more versatility.  All whitespace is stripped from formulas that are entered. So,  1 + x ^ 2  is equivalent to  1+x^2 .", 
            "title": "FormulaGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#variables-and-sampling", 
            "text": "FormulaGrader grades a formula by numerical sampling. That is, random values are  assigned to each of the unknown variables and unknown functions, then the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.  Variables are configured by including a list of strings of each variable name as follows.  grader = FormulaGrader(\n    answers='1+x^2+y',\n    variables=['x', 'y']\n)  Note that the  answers  parameter follows all of the usual allowances from ItemGrader.  The variables need to have numbers randomly assigned to them. Each is sampled from a  sampling set , which is RealInterval() by default (random numbers from 1 to 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the  sample_from  key.  grader = FormulaGrader(\n    answers='1+x^2+y+z/2',\n    variables=['x', 'y', 'z'],\n    sample_from={\n        'x': ComplexRectangle(),\n        'y': [2, 6],\n        'z': (1, 3, 4, 8)\n    }\n)  The  sample_from  key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.", 
            "title": "Variables and Sampling"
        }, 
        {
            "location": "/grading_math/formula_grader/#numbered-variables", 
            "text": "You can also specify special variables that are numbered. For example, if you specify that  a  is a numbered variable, students can include  a_{0} ,  a_{5} ,  a_{-2} , etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.  grader = FormulaGrader(\n    answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n    variables=['x'],\n    numbered_vars=['a'],\n    sample_from={\n        'x': [-5, 5],\n        'a': [-10, 10]\n    }\n)  If you have a variable name that would clash with a numbered variable (say, you defined  a_{0}  and also a numbered variable  a ), then the specific variable has precedence.", 
            "title": "Numbered Variables"
        }, 
        {
            "location": "/grading_math/formula_grader/#samples-and-failable-evaluations", 
            "text": "To control the number of samples that are checked to ensure correctness, you can modify the  samples  key.  grader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10\n)  The default for  samples  is 5.  You may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set  failable_evals . This should be used very sparingly!  grader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10,\n    failable_evals=1\n)", 
            "title": "Samples and Failable Evaluations"
        }, 
        {
            "location": "/grading_math/formula_grader/#functions", 
            "text": "By default, a large array of mathematical functions are available for use. See the full list  here . Note that functions for manipulating complex variables are available, which allows you to grade complex expressions. In the following example,  z*z  is recognized to be different from  abs(z)^2 .  grader = FormulaGrader(\n    answers='abs(z)^2',\n    variables=['z'],\n    sample_from={\n        'z': ComplexRectangle()\n    }\n)", 
            "title": "Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#user-functions", 
            "text": "You can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the  user_functions  key as follows.  grader = FormulaGrader(\n    answers='x*x',\n    variables=['x'],\n    user_functions={'f': lambda x: x*x}\n)  This defines a function  f(x) = x^2 . User-defined function names must start with a letter, and can use numbers and underscores, such as  my_func2 . They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg,  f'' . Be careful about using quotation marks appropriately when using primes in function names!  grader = FormulaGrader(\n    answers= f''(x) ,\n    variables=['x'],\n    user_functions={ f'' : lambda x: x*x}\n)  You can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.  grader = FormulaGrader(\n    answers= f(x) ,\n    variables=['x'],\n    user_functions={ f : [np.sin, np.cos]}\n)  Each time this formula is checked, the function  f  will be sampled from the list of available functions.  You can also specify a random well-behaved function by using the RandomFunction() sampling set.  grader = FormulaGrader(\n    answers= f''(x) + omega^2*f(x) ,\n    variables=['x', 'omega'],\n    user_functions={\n         f : RandomFunction(),\n         f'' : RandomFunction()\n    }\n)  This allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example.", 
            "title": "User Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#constants", 
            "text": "By default, four constants are defined:  e ,  pi , and  i=j=sqrt(-1) . You can define new constants by passing in a dictionary to  user_constants  as follows.  grader = FormulaGrader(\n    answers='1/sqrt(1-v^2/c^2)',\n    variables=['v'],\n    user_constants={\n        'c': 3e8\n    }\n)  Constants are like variables that only ever have one value.", 
            "title": "Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#overriding-default-functions-and-constants", 
            "text": "You can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with  suppress_warnings=True . The grader  grader = FormulaGrader(\n    answers='x^2',\n    variables=['x'],\n    user_functions={'sin': lambda x: x*x},\n)  will raise an error   ConfigError: Warning: 'user_functions' contains entries '['sin']' which will override default values. If you intend to override to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.   The error can be suppressed by setting  suppress_warnings=True .", 
            "title": "Overriding Default Functions and Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#restricting-student-input", 
            "text": "For some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand  sin(2*theta) , then you don't want students to be able to just write  sin(2*theta)  and be graded correct.  FormulaGrader offers a few ways to restrict what sort of answers will be marked correct.", 
            "title": "Restricting Student Input"
        }, 
        {
            "location": "/grading_math/formula_grader/#forbidden-strings", 
            "text": "You can forbid students from entering certain strings using the  forbidden_strings  key:  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n    forbidden_message= Your answer should only use trigonometric functions acting on theta, not multiples of theta \n)  If a student tries to use one of these strings, then they receive the  forbidden_message , without giving away what the forbidden string is. We recommend using this sparingly, as students will find it confusing. The default  forbidden_message  is \"Invalid Input: This particular answer is forbidden\".  Forbidden strings and student answers are stripped of whitespace before being compared. Thus, if  x + y  is forbidden, then answers containing  x+y  or  x   +   y  will be rejected.", 
            "title": "Forbidden Strings"
        }, 
        {
            "location": "/grading_math/formula_grader/#blacklists-and-whitelists", 
            "text": "You can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example,  sin  is disallowed in correct answers.  grader = FormulaGrader(\n    answers='sqrt(1 - cos(x)^2)',\n    variables=['x'],\n    sample_from={'x': [0, np.pi]},\n    blacklist=['sin']\n)  If you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos.  grader = FormulaGrader(\n    answers='sin(x)/cos(x)',\n    variables=['x'],\n    whitelist=['sin', 'cos']\n)  If you want to exclude all functions, use  whitelist=[None] :  grader = FormulaGrader(\n    answers='pi/2-x',\n    variables=['x'],\n    whitelist=[None] # no functions are allowed\n)  You cannot use a whitelist and a blacklist at the same time.", 
            "title": "Blacklists and Whitelists"
        }, 
        {
            "location": "/grading_math/formula_grader/#required-functions", 
            "text": "You can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    required_functions=['sin', 'cos']\n)", 
            "title": "Required Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#tolerance", 
            "text": "Student inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg,  0.1 ) or a percentage (eg,  \"0.01%\" , which is the default tolerance).  Tolerances must be nonnegative numbers or percentages.  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    tolerance=0.00001\n)  Tolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.", 
            "title": "Tolerance"
        }, 
        {
            "location": "/grading_math/formula_grader/#case-sensitive-input", 
            "text": "All expressions are treated in a case sensitive manner. This means that variables  m  and  M  are distinct variables. Prior to version 1.1, we had a case-insensitive option available. However, this option is now deprecated, as it was causing issues in the codebase, nobody was using it (that we know of), and the majority of languages are case-sensitive anway.", 
            "title": "Case Sensitive Input"
        }, 
        {
            "location": "/grading_math/formula_grader/#suffixes", 
            "text": "Numbers with a % at the end will be treated as percentages, and converted to the appropriate decimals.  edX also defines a number of metric suffixes (k, M, G, T, m, u, n, and p) that modify a number appropriately. However, in our experience, these metric suffixes lead to more confusion than use. For example,  2M , which one would expect should be rejected as an error when  2*M  was intended, is accepted by edX, interpreted as  2*10^6 , marked incorrect, and eats a student's attempt. Similarly for all of the other metric suffixes.  We have therefore made the decision to disable metric suffixes by default. If you want to enable them, you can do so using the following.  grader = FormulaGrader(\n    answers='2*m',\n    variables=['m'],\n    metric_suffixes=True\n)  We strongly recommend  not  doing this when using the following variable names: k, M, G, T, m, u, n, and p.", 
            "title": "Suffixes"
        }, 
        {
            "location": "/grading_math/formula_grader/#comparer-functions", 
            "text": "By default, FormulaGrader compares the numerically sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. For example, if grading angles in degrees, it may be useful to compare formulas modulo 360.  To use an alternate comparer, specify the  answers  key as a dictionary with keys  comparer  and  comparer_params  rather than a single string. For example, to compare formulas modulo 360:  def is_coterminal(comparer_params_evals, student_eval, utils):\n    answer = comparer_params_evals[0]\n    reduced = student_eval % (360)\n    return utils.within_tolerance(answer, reduced)\n\ngrader = FormulaGrader(\n    answers={\n        'comparer': is_coterminal,\n        'comparer_params': ['b^2/a'],\n    },\n    variables=['a', 'b'],\n    tolerance='1%'\n)  This grader would accept  'b^2/a'  as well as  'b^2/a + 360' ,  'b^2/a + 720' , etc.  In the grader configuration,  comparer_params  is a list of strings that are numerically evaluated and passed to the comparer function. The  comparer  function is a user-specified function with signature  comparer(comparer_params_evals, student_eval, utils) . When  FormulaGrader  calls the comparer function,  comparer  the argument values are:\n-  comparer_params_evals : The  comparer_params  list, numerically evaluated according to variable and function sampling.\n-  student_eval : The student's input, numerically evaluated according to variable and function sampling\n-  utils : A convenience object that may be helpful when writing custom comparer functions. Has properties:\n  -  utils.tolerance : The tolerance specified in grader configuration,  0.01%  by default\n  -  utils.within_tolerance:  A function with signature  within_tolerance(x, y)  which checks that  y  is within specified tolerance of  x . Can handle scalars, vectors, and matrices. If tolerance was specified as a percentage, then checks that  |x-y|   tolerance * x .", 
            "title": "Comparer Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#other-improvements", 
            "text": "We have made a number of other improvements over the edX formula graders, including:   Square roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like  sqrt(x-1)  or  (x-1)^0.5  always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.  Our parser uses a parsing cache, and hence runs much more efficiently than the edX graders.  If students input an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.  When students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.  Similarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.  If an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the  debug  flag to True, and a more technical message will usually be displayed.  Full sampling details are included when the  debug  flag is set to True.   Enhancements to the AsciiMath renderer (the preview that students see when using  textline  inputs) are available using our  AsciiMath renderer definitions .    Home", 
            "title": "Other Improvements"
        }, 
        {
            "location": "/grading_math/formula_grader/", 
            "text": "FormulaGrader\n\n\nFormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's \nformularesponse /\n tag, but with much more versatility.\n\n\nAll whitespace is stripped from formulas that are entered. So, \n1 + x ^ 2\n is equivalent to \n1+x^2\n.\n\n\nVariables and Sampling\n\n\nFormulaGrader grades a formula by numerical sampling. That is, random values are  assigned to each of the unknown variables and unknown functions, then the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.\n\n\nVariables are configured by including a list of strings of each variable name as follows.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2+y',\n    variables=['x', 'y']\n)\n\n\n\n\nNote that the \nanswers\n parameter follows all of the usual allowances from ItemGrader.\n\n\nThe variables need to have numbers randomly assigned to them. Each is sampled from a \nsampling set\n, which is RealInterval() by default (random numbers from 1 to 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the \nsample_from\n key.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2+y+z/2',\n    variables=['x', 'y', 'z'],\n    sample_from={\n        'x': ComplexRectangle(),\n        'y': [2, 6],\n        'z': (1, 3, 4, 8)\n    }\n)\n\n\n\n\nThe \nsample_from\n key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.\n\n\nNumbered Variables\n\n\nYou can also specify special variables that are numbered. For example, if you specify that \na\n is a numbered variable, students can include \na_{0}\n, \na_{5}\n, \na_{-2}\n, etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.\n\n\ngrader = FormulaGrader(\n    answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n    variables=['x'],\n    numbered_vars=['a'],\n    sample_from={\n        'x': [-5, 5],\n        'a': [-10, 10]\n    }\n)\n\n\n\n\nIf you have a variable name that would clash with a numbered variable (say, you defined \na_{0}\n and also a numbered variable \na\n), then the specific variable has precedence.\n\n\nSamples and Failable Evaluations\n\n\nTo control the number of samples that are checked to ensure correctness, you can modify the \nsamples\n key.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10\n)\n\n\n\n\nThe default for \nsamples\n is 5.\n\n\nYou may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set \nfailable_evals\n. This should be used very sparingly!\n\n\ngrader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10,\n    failable_evals=1\n)\n\n\n\n\nFunctions\n\n\nBy default, a large array of mathematical functions are available for use. See the full list \nhere\n. Note that functions for manipulating complex variables are available, which allows you to grade complex expressions. In the following example, \nz*z\n is recognized to be different from \nabs(z)^2\n.\n\n\ngrader = FormulaGrader(\n    answers='abs(z)^2',\n    variables=['z'],\n    sample_from={\n        'z': ComplexRectangle()\n    }\n)\n\n\n\n\nUser Functions\n\n\nYou can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the \nuser_functions\n key as follows.\n\n\ngrader = FormulaGrader(\n    answers='x*x',\n    variables=['x'],\n    user_functions={'f': lambda x: x*x}\n)\n\n\n\n\nThis defines a function \nf(x) = x^2\n. User-defined function names must start with a letter, and can use numbers and underscores, such as \nmy_func2\n. They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg, \nf''\n. Be careful about using quotation marks appropriately when using primes in function names!\n\n\ngrader = FormulaGrader(\n    answers=\nf''(x)\n,\n    variables=['x'],\n    user_functions={\nf''\n: lambda x: x*x}\n)\n\n\n\n\nYou can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.\n\n\ngrader = FormulaGrader(\n    answers=\nf(x)\n,\n    variables=['x'],\n    user_functions={\nf\n: [np.sin, np.cos]}\n)\n\n\n\n\nEach time this formula is checked, the function \nf\n will be sampled from the list of available functions.\n\n\nYou can also specify a random well-behaved function by using the RandomFunction() sampling set.\n\n\ngrader = FormulaGrader(\n    answers=\nf''(x) + omega^2*f(x)\n,\n    variables=['x', 'omega'],\n    user_functions={\n        \nf\n: RandomFunction(),\n        \nf''\n: RandomFunction()\n    }\n)\n\n\n\n\nThis allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example.\n\n\nConstants\n\n\nBy default, four constants are defined: \ne\n, \npi\n, and \ni=j=sqrt(-1)\n. You can define new constants by passing in a dictionary to \nuser_constants\n as follows.\n\n\ngrader = FormulaGrader(\n    answers='1/sqrt(1-v^2/c^2)',\n    variables=['v'],\n    user_constants={\n        'c': 3e8\n    }\n)\n\n\n\n\nConstants are like variables that only ever have one value.\n\n\nOverriding Default Functions and Constants\n\n\nYou can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with \nsuppress_warnings=True\n. The grader\n\n\ngrader = FormulaGrader(\n    answers='x^2',\n    variables=['x'],\n    user_functions={'sin': lambda x: x*x},\n)\n\n\n\n\nwill raise an error\n\n\n\n\nConfigError: Warning: 'user_functions' contains entries '['sin']' which will override default values. If you intend to override to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.\n\n\n\n\nThe error can be suppressed by setting \nsuppress_warnings=True\n.\n\n\nRestricting Student Input\n\n\nFor some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand \nsin(2*theta)\n, then you don't want students to be able to just write \nsin(2*theta)\n and be graded correct.\n\n\nFormulaGrader offers a few ways to restrict what sort of answers will be marked correct.\n\n\nForbidden Strings\n\n\nYou can forbid students from entering certain strings using the \nforbidden_strings\n key:\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n    forbidden_message=\nYour answer should only use trigonometric functions acting on theta, not multiples of theta\n\n)\n\n\n\n\nIf a student tries to use one of these strings, then they receive the \nforbidden_message\n, without giving away what the forbidden string is. We recommend using this sparingly, as students will find it confusing. The default \nforbidden_message\n is \"Invalid Input: This particular answer is forbidden\".\n\n\nForbidden strings and student answers are stripped of whitespace before being compared. Thus, if \nx + y\n is forbidden, then answers containing \nx+y\n or \nx   +   y\n will be rejected.\n\n\nBlacklists and Whitelists\n\n\nYou can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example, \nsin\n is disallowed in correct answers.\n\n\ngrader = FormulaGrader(\n    answers='sqrt(1 - cos(x)^2)',\n    variables=['x'],\n    sample_from={'x': [0, np.pi]},\n    blacklist=['sin']\n)\n\n\n\n\nIf you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos.\n\n\ngrader = FormulaGrader(\n    answers='sin(x)/cos(x)',\n    variables=['x'],\n    whitelist=['sin', 'cos']\n)\n\n\n\n\nIf you want to exclude all functions, use \nwhitelist=[None]\n:\n\n\ngrader = FormulaGrader(\n    answers='pi/2-x',\n    variables=['x'],\n    whitelist=[None] # no functions are allowed\n)\n\n\n\n\nYou cannot use a whitelist and a blacklist at the same time.\n\n\nRequired Functions\n\n\nYou can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    required_functions=['sin', 'cos']\n)\n\n\n\n\nTolerance\n\n\nStudent inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg, \n0.1\n) or a percentage (eg, \n\"0.01%\"\n, which is the default tolerance).  Tolerances must be nonnegative numbers or percentages.\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    tolerance=0.00001\n)\n\n\n\n\nTolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.\n\n\nCase Sensitive Input\n\n\nAll expressions are treated in a case sensitive manner. This means that variables \nm\n and \nM\n are distinct variables. Prior to version 1.1, we had a case-insensitive option available. However, this option is now deprecated, as it was causing issues in the codebase, nobody was using it (that we know of), and the majority of languages are case-sensitive anway.\n\n\nSuffixes\n\n\nNumbers with a % at the end will be treated as percentages, and converted to the appropriate decimals.\n\n\nedX also defines a number of metric suffixes (k, M, G, T, m, u, n, and p) that modify a number appropriately. However, in our experience, these metric suffixes lead to more confusion than use. For example, \n2M\n, which one would expect should be rejected as an error when \n2*M\n was intended, is accepted by edX, interpreted as \n2*10^6\n, marked incorrect, and eats a student's attempt. Similarly for all of the other metric suffixes.\n\n\nWe have therefore made the decision to disable metric suffixes by default. If you want to enable them, you can do so using the following.\n\n\ngrader = FormulaGrader(\n    answers='2*m',\n    variables=['m'],\n    metric_suffixes=True\n)\n\n\n\n\nWe strongly recommend \nnot\n doing this when using the following variable names: k, M, G, T, m, u, n, and p.\n\n\nComparer Functions\n\n\nBy default, FormulaGrader compares the numerically sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. For example, if grading angles in degrees, it may be useful to compare formulas modulo 360.\n\n\nTo use an alternate comparer, specify the \nanswers\n key as a dictionary with keys \ncomparer\n and \ncomparer_params\n rather than a single string. For example, to compare formulas modulo 360:\n\n\ndef is_coterminal(comparer_params_evals, student_eval, utils):\n    answer = comparer_params_evals[0]\n    reduced = student_eval % (360)\n    return utils.within_tolerance(answer, reduced)\n\ngrader = FormulaGrader(\n    answers={\n        'comparer': is_coterminal,\n        'comparer_params': ['b^2/a'],\n    },\n    variables=['a', 'b'],\n    tolerance='1%'\n)\n\n\n\n\nThis grader would accept \n'b^2/a'\n as well as \n'b^2/a + 360'\n, \n'b^2/a + 720'\n, etc.\n\n\nIn the grader configuration, \ncomparer_params\n is a list of strings that are numerically evaluated and passed to the comparer function. The \ncomparer\n function is a user-specified function with signature \ncomparer(comparer_params_evals, student_eval, utils)\n. When \nFormulaGrader\n calls the comparer function, \ncomparer\n the argument values are:\n- \ncomparer_params_evals\n: The \ncomparer_params\n list, numerically evaluated according to variable and function sampling.\n- \nstudent_eval\n: The student's input, numerically evaluated according to variable and function sampling\n- \nutils\n: A convenience object that may be helpful when writing custom comparer functions. Has properties:\n  - \nutils.tolerance\n: The tolerance specified in grader configuration, \n0.01%\n by default\n  - \nutils.within_tolerance:\n A function with signature \nwithin_tolerance(x, y)\n which checks that \ny\n is within specified tolerance of \nx\n. Can handle scalars, vectors, and matrices. If tolerance was specified as a percentage, then checks that \n|x-y| \n tolerance * x\n.\n\n\nOther Improvements\n\n\nWe have made a number of other improvements over the edX formula graders, including:\n\n\n\n\nSquare roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like \nsqrt(x-1)\n or \n(x-1)^0.5\n always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.\n\n\nOur parser uses a parsing cache, and hence runs much more efficiently than the edX graders.\n\n\nIf students input an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.\n\n\nWhen students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.\n\n\nSimilarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.\n\n\nIf an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the \ndebug\n flag to True, and a more technical message will usually be displayed.\n\n\nFull sampling details are included when the \ndebug\n flag is set to True.\n\n\n\n\nEnhancements to the AsciiMath renderer (the preview that students see when using \ntextline\n inputs) are available using our \nAsciiMath renderer definitions\n.\n\n\n\n\n\n\nHome", 
            "title": "NumericalGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#formulagrader", 
            "text": "FormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's  formularesponse /  tag, but with much more versatility.  All whitespace is stripped from formulas that are entered. So,  1 + x ^ 2  is equivalent to  1+x^2 .", 
            "title": "FormulaGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#variables-and-sampling", 
            "text": "FormulaGrader grades a formula by numerical sampling. That is, random values are  assigned to each of the unknown variables and unknown functions, then the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.  Variables are configured by including a list of strings of each variable name as follows.  grader = FormulaGrader(\n    answers='1+x^2+y',\n    variables=['x', 'y']\n)  Note that the  answers  parameter follows all of the usual allowances from ItemGrader.  The variables need to have numbers randomly assigned to them. Each is sampled from a  sampling set , which is RealInterval() by default (random numbers from 1 to 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the  sample_from  key.  grader = FormulaGrader(\n    answers='1+x^2+y+z/2',\n    variables=['x', 'y', 'z'],\n    sample_from={\n        'x': ComplexRectangle(),\n        'y': [2, 6],\n        'z': (1, 3, 4, 8)\n    }\n)  The  sample_from  key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.", 
            "title": "Variables and Sampling"
        }, 
        {
            "location": "/grading_math/formula_grader/#numbered-variables", 
            "text": "You can also specify special variables that are numbered. For example, if you specify that  a  is a numbered variable, students can include  a_{0} ,  a_{5} ,  a_{-2} , etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.  grader = FormulaGrader(\n    answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n    variables=['x'],\n    numbered_vars=['a'],\n    sample_from={\n        'x': [-5, 5],\n        'a': [-10, 10]\n    }\n)  If you have a variable name that would clash with a numbered variable (say, you defined  a_{0}  and also a numbered variable  a ), then the specific variable has precedence.", 
            "title": "Numbered Variables"
        }, 
        {
            "location": "/grading_math/formula_grader/#samples-and-failable-evaluations", 
            "text": "To control the number of samples that are checked to ensure correctness, you can modify the  samples  key.  grader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10\n)  The default for  samples  is 5.  You may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set  failable_evals . This should be used very sparingly!  grader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10,\n    failable_evals=1\n)", 
            "title": "Samples and Failable Evaluations"
        }, 
        {
            "location": "/grading_math/formula_grader/#functions", 
            "text": "By default, a large array of mathematical functions are available for use. See the full list  here . Note that functions for manipulating complex variables are available, which allows you to grade complex expressions. In the following example,  z*z  is recognized to be different from  abs(z)^2 .  grader = FormulaGrader(\n    answers='abs(z)^2',\n    variables=['z'],\n    sample_from={\n        'z': ComplexRectangle()\n    }\n)", 
            "title": "Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#user-functions", 
            "text": "You can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the  user_functions  key as follows.  grader = FormulaGrader(\n    answers='x*x',\n    variables=['x'],\n    user_functions={'f': lambda x: x*x}\n)  This defines a function  f(x) = x^2 . User-defined function names must start with a letter, and can use numbers and underscores, such as  my_func2 . They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg,  f'' . Be careful about using quotation marks appropriately when using primes in function names!  grader = FormulaGrader(\n    answers= f''(x) ,\n    variables=['x'],\n    user_functions={ f'' : lambda x: x*x}\n)  You can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.  grader = FormulaGrader(\n    answers= f(x) ,\n    variables=['x'],\n    user_functions={ f : [np.sin, np.cos]}\n)  Each time this formula is checked, the function  f  will be sampled from the list of available functions.  You can also specify a random well-behaved function by using the RandomFunction() sampling set.  grader = FormulaGrader(\n    answers= f''(x) + omega^2*f(x) ,\n    variables=['x', 'omega'],\n    user_functions={\n         f : RandomFunction(),\n         f'' : RandomFunction()\n    }\n)  This allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example.", 
            "title": "User Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#constants", 
            "text": "By default, four constants are defined:  e ,  pi , and  i=j=sqrt(-1) . You can define new constants by passing in a dictionary to  user_constants  as follows.  grader = FormulaGrader(\n    answers='1/sqrt(1-v^2/c^2)',\n    variables=['v'],\n    user_constants={\n        'c': 3e8\n    }\n)  Constants are like variables that only ever have one value.", 
            "title": "Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#overriding-default-functions-and-constants", 
            "text": "You can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with  suppress_warnings=True . The grader  grader = FormulaGrader(\n    answers='x^2',\n    variables=['x'],\n    user_functions={'sin': lambda x: x*x},\n)  will raise an error   ConfigError: Warning: 'user_functions' contains entries '['sin']' which will override default values. If you intend to override to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.   The error can be suppressed by setting  suppress_warnings=True .", 
            "title": "Overriding Default Functions and Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#restricting-student-input", 
            "text": "For some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand  sin(2*theta) , then you don't want students to be able to just write  sin(2*theta)  and be graded correct.  FormulaGrader offers a few ways to restrict what sort of answers will be marked correct.", 
            "title": "Restricting Student Input"
        }, 
        {
            "location": "/grading_math/formula_grader/#forbidden-strings", 
            "text": "You can forbid students from entering certain strings using the  forbidden_strings  key:  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n    forbidden_message= Your answer should only use trigonometric functions acting on theta, not multiples of theta \n)  If a student tries to use one of these strings, then they receive the  forbidden_message , without giving away what the forbidden string is. We recommend using this sparingly, as students will find it confusing. The default  forbidden_message  is \"Invalid Input: This particular answer is forbidden\".  Forbidden strings and student answers are stripped of whitespace before being compared. Thus, if  x + y  is forbidden, then answers containing  x+y  or  x   +   y  will be rejected.", 
            "title": "Forbidden Strings"
        }, 
        {
            "location": "/grading_math/formula_grader/#blacklists-and-whitelists", 
            "text": "You can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example,  sin  is disallowed in correct answers.  grader = FormulaGrader(\n    answers='sqrt(1 - cos(x)^2)',\n    variables=['x'],\n    sample_from={'x': [0, np.pi]},\n    blacklist=['sin']\n)  If you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos.  grader = FormulaGrader(\n    answers='sin(x)/cos(x)',\n    variables=['x'],\n    whitelist=['sin', 'cos']\n)  If you want to exclude all functions, use  whitelist=[None] :  grader = FormulaGrader(\n    answers='pi/2-x',\n    variables=['x'],\n    whitelist=[None] # no functions are allowed\n)  You cannot use a whitelist and a blacklist at the same time.", 
            "title": "Blacklists and Whitelists"
        }, 
        {
            "location": "/grading_math/formula_grader/#required-functions", 
            "text": "You can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    required_functions=['sin', 'cos']\n)", 
            "title": "Required Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#tolerance", 
            "text": "Student inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg,  0.1 ) or a percentage (eg,  \"0.01%\" , which is the default tolerance).  Tolerances must be nonnegative numbers or percentages.  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    tolerance=0.00001\n)  Tolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.", 
            "title": "Tolerance"
        }, 
        {
            "location": "/grading_math/formula_grader/#case-sensitive-input", 
            "text": "All expressions are treated in a case sensitive manner. This means that variables  m  and  M  are distinct variables. Prior to version 1.1, we had a case-insensitive option available. However, this option is now deprecated, as it was causing issues in the codebase, nobody was using it (that we know of), and the majority of languages are case-sensitive anway.", 
            "title": "Case Sensitive Input"
        }, 
        {
            "location": "/grading_math/formula_grader/#suffixes", 
            "text": "Numbers with a % at the end will be treated as percentages, and converted to the appropriate decimals.  edX also defines a number of metric suffixes (k, M, G, T, m, u, n, and p) that modify a number appropriately. However, in our experience, these metric suffixes lead to more confusion than use. For example,  2M , which one would expect should be rejected as an error when  2*M  was intended, is accepted by edX, interpreted as  2*10^6 , marked incorrect, and eats a student's attempt. Similarly for all of the other metric suffixes.  We have therefore made the decision to disable metric suffixes by default. If you want to enable them, you can do so using the following.  grader = FormulaGrader(\n    answers='2*m',\n    variables=['m'],\n    metric_suffixes=True\n)  We strongly recommend  not  doing this when using the following variable names: k, M, G, T, m, u, n, and p.", 
            "title": "Suffixes"
        }, 
        {
            "location": "/grading_math/formula_grader/#comparer-functions", 
            "text": "By default, FormulaGrader compares the numerically sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. For example, if grading angles in degrees, it may be useful to compare formulas modulo 360.  To use an alternate comparer, specify the  answers  key as a dictionary with keys  comparer  and  comparer_params  rather than a single string. For example, to compare formulas modulo 360:  def is_coterminal(comparer_params_evals, student_eval, utils):\n    answer = comparer_params_evals[0]\n    reduced = student_eval % (360)\n    return utils.within_tolerance(answer, reduced)\n\ngrader = FormulaGrader(\n    answers={\n        'comparer': is_coterminal,\n        'comparer_params': ['b^2/a'],\n    },\n    variables=['a', 'b'],\n    tolerance='1%'\n)  This grader would accept  'b^2/a'  as well as  'b^2/a + 360' ,  'b^2/a + 720' , etc.  In the grader configuration,  comparer_params  is a list of strings that are numerically evaluated and passed to the comparer function. The  comparer  function is a user-specified function with signature  comparer(comparer_params_evals, student_eval, utils) . When  FormulaGrader  calls the comparer function,  comparer  the argument values are:\n-  comparer_params_evals : The  comparer_params  list, numerically evaluated according to variable and function sampling.\n-  student_eval : The student's input, numerically evaluated according to variable and function sampling\n-  utils : A convenience object that may be helpful when writing custom comparer functions. Has properties:\n  -  utils.tolerance : The tolerance specified in grader configuration,  0.01%  by default\n  -  utils.within_tolerance:  A function with signature  within_tolerance(x, y)  which checks that  y  is within specified tolerance of  x . Can handle scalars, vectors, and matrices. If tolerance was specified as a percentage, then checks that  |x-y|   tolerance * x .", 
            "title": "Comparer Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#other-improvements", 
            "text": "We have made a number of other improvements over the edX formula graders, including:   Square roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like  sqrt(x-1)  or  (x-1)^0.5  always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.  Our parser uses a parsing cache, and hence runs much more efficiently than the edX graders.  If students input an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.  When students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.  Similarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.  If an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the  debug  flag to True, and a more technical message will usually be displayed.  Full sampling details are included when the  debug  flag is set to True.   Enhancements to the AsciiMath renderer (the preview that students see when using  textline  inputs) are available using our  AsciiMath renderer definitions .    Home", 
            "title": "Other Improvements"
        }, 
        {
            "location": "/grading_math/sampling/", 
            "text": "Sampling\n\n\nWhenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called \nsampling sets\n. We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins.\n\n\nThese sampling classes are available for use in FormulaGrader.\n\n\nTable of Contents\n\n\n\n\nVariable Names\n\n\nVariable Sampling\n\n\nRealInterval\n\n\nIntegerRange\n\n\nDiscreteSet\n\n\nComplexRectangle\n\n\nComplexSector\n\n\nDependentSampler\n\n\nFunction Sampling\n\n\nSpecificFunctions\n\n\nRandomFunction\n\n\n\n\nVariable Names\n\n\nVariable names must start with a letter, and can continue with letters, numbers, and underscores. Variable names may conclude with an arbitrary number of apostrophes. The same naming conventions apply to user-defined constants.\n\n\nIt is also possible to have tensor variable names. The following three forms are available:\n\n\n\n\nT^{ijk}\n\n\nT_{ijk}\n\n\nT_{ijk}^{123} (note that lowered indices must come first)\n\n\n\n\nThe tensor name itself must start with a letter, and may continue with letters and numbers. The indices may be any combination of letters and numbers. After the indices, you may have apostrophes, such as T^{ijk}'' (tensors can be differentiated too!).\n\n\nVariable Sampling\n\n\nThese sampling sets generate a random number on demand. It may be real or complex.\n\n\nRealInterval\n\n\nSample from a real interval defined by a \nstart\n and a \nstop\n value. RealInterval can be initialized using explicit values, or an interval.\n\n\n# Generate random real numbers between 3 and 7\nsampler = RealInterval(start=3, stop=7)\n# This is equivalent to\nsampler = RealInterval([3, 7])\n# The default is [1, 5]\nsampler = RealInterval()\n\n\n\n\nIntegerRange\n\n\nSample from an integer defined by a \nstart\n and a \nstop\n value (both start and stop are included in the range). IntegerRange can be initialized using explicit values, or an interval.\n\n\n# Generate random integers between 3 and 7 inclusive\nsampler = IntegerRange(start=3, stop=7)\n# This is equivalent to\nsampler = IntegerRange([3, 7])\n# The default is [1, 5]\nsampler = IntegerRange()\n\n\n\n\nDiscreteSet\n\n\nSample from a discrete set of values, specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set.\n\n\n# Select random numbers from (1, 3, 5, 7, 9)\nsampler = DiscreteSet((1, 3, 5, 7, 9))\n# Always select 3.5\nsampler = DiscreteSet(3.5)\n\n\n\n\nComplexRectangle\n\n\nSample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range.\n\n\n# Select random complex numbers from 0 to 1 + i\nsampler = ComplexRectangle(re=[0, 1], im=[0, 1])\n# The default is re=[1, 3], im=[1, 3]\nsampler = ComplexRectangle()\n\n\n\n\nComplexSector\n\n\nSample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range.\n\n\n# Select random complex numbers from inside the unit circle\nsampler = ComplexSector(modulus=[0, 1], argument=[-np.pi, np.pi])\n# The default is modulus=[1, 3], argument=[0, pi/2]\nsampler = ComplexSector()\n\n\n\n\nDependentSampler\n\n\nCompute a value for a variable based on the values of other variables. The sampler must be initialized with a list of variables that it depends on, as well as the formula used to perform the computation. The formula can use any base functions, but no user-defined functions. DependentSamplers can depend on other dependent variables. If you construct a self-referential chain, an error will occur.\n\n\n# Set radius based on the random values of x, y and z\nsampler = DependentSampler(depends=[\nx\n, \ny\n, \nz\n], formula=\nsqrt(x^2+y^2+z^2)\n)\n\n\n\n\nFunction Sampling\n\n\nWhen a random function can be specified, we need a sampling set that returns a random function on demand.\n\n\nSpecificFunctions\n\n\nSamples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set.\n\n\n# Select either sin or cos randomly\nfunctionsampler = SpecificFunctions([np.cos, np.sin])\n# Always select a single lambda function\nfunctionsampler = SpecificFunctions(lambda x: x*x)\n\n\n\n\nRandomFunction\n\n\nGenerate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude.\n\n\n# Generate a random function\nfunctionsampler = RandomFunction(center=1, amplitude=2)\n# The default is center=0, amplitude=10\nfunctionsampler = RandomFunction()\n\n\n\n\nYou can control how many random sinusoids are added together by specifying \nnum_terms\n.\n\n\n# Generate a random sinusoid\nfunctionsampler = RandomFunction(num_terms=1)\n\n\n\n\nYou can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension.\n\n\n# Generate a function that takes in two values and outputs a 3D vector\nfunctionsampler = RandomFunction(input_dim=2, output_dim=3)\n\n\n\n\n\n\nFormulaGrader and NumericalGrader\n\n\nHome", 
            "title": "Sampling Sets"
        }, 
        {
            "location": "/grading_math/sampling/#sampling", 
            "text": "Whenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called  sampling sets . We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins.  These sampling classes are available for use in FormulaGrader.  Table of Contents   Variable Names  Variable Sampling  RealInterval  IntegerRange  DiscreteSet  ComplexRectangle  ComplexSector  DependentSampler  Function Sampling  SpecificFunctions  RandomFunction", 
            "title": "Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#variable-names", 
            "text": "Variable names must start with a letter, and can continue with letters, numbers, and underscores. Variable names may conclude with an arbitrary number of apostrophes. The same naming conventions apply to user-defined constants.  It is also possible to have tensor variable names. The following three forms are available:   T^{ijk}  T_{ijk}  T_{ijk}^{123} (note that lowered indices must come first)   The tensor name itself must start with a letter, and may continue with letters and numbers. The indices may be any combination of letters and numbers. After the indices, you may have apostrophes, such as T^{ijk}'' (tensors can be differentiated too!).", 
            "title": "Variable Names"
        }, 
        {
            "location": "/grading_math/sampling/#variable-sampling", 
            "text": "These sampling sets generate a random number on demand. It may be real or complex.", 
            "title": "Variable Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#realinterval", 
            "text": "Sample from a real interval defined by a  start  and a  stop  value. RealInterval can be initialized using explicit values, or an interval.  # Generate random real numbers between 3 and 7\nsampler = RealInterval(start=3, stop=7)\n# This is equivalent to\nsampler = RealInterval([3, 7])\n# The default is [1, 5]\nsampler = RealInterval()", 
            "title": "RealInterval"
        }, 
        {
            "location": "/grading_math/sampling/#integerrange", 
            "text": "Sample from an integer defined by a  start  and a  stop  value (both start and stop are included in the range). IntegerRange can be initialized using explicit values, or an interval.  # Generate random integers between 3 and 7 inclusive\nsampler = IntegerRange(start=3, stop=7)\n# This is equivalent to\nsampler = IntegerRange([3, 7])\n# The default is [1, 5]\nsampler = IntegerRange()", 
            "title": "IntegerRange"
        }, 
        {
            "location": "/grading_math/sampling/#discreteset", 
            "text": "Sample from a discrete set of values, specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set.  # Select random numbers from (1, 3, 5, 7, 9)\nsampler = DiscreteSet((1, 3, 5, 7, 9))\n# Always select 3.5\nsampler = DiscreteSet(3.5)", 
            "title": "DiscreteSet"
        }, 
        {
            "location": "/grading_math/sampling/#complexrectangle", 
            "text": "Sample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range.  # Select random complex numbers from 0 to 1 + i\nsampler = ComplexRectangle(re=[0, 1], im=[0, 1])\n# The default is re=[1, 3], im=[1, 3]\nsampler = ComplexRectangle()", 
            "title": "ComplexRectangle"
        }, 
        {
            "location": "/grading_math/sampling/#complexsector", 
            "text": "Sample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range.  # Select random complex numbers from inside the unit circle\nsampler = ComplexSector(modulus=[0, 1], argument=[-np.pi, np.pi])\n# The default is modulus=[1, 3], argument=[0, pi/2]\nsampler = ComplexSector()", 
            "title": "ComplexSector"
        }, 
        {
            "location": "/grading_math/sampling/#dependentsampler", 
            "text": "Compute a value for a variable based on the values of other variables. The sampler must be initialized with a list of variables that it depends on, as well as the formula used to perform the computation. The formula can use any base functions, but no user-defined functions. DependentSamplers can depend on other dependent variables. If you construct a self-referential chain, an error will occur.  # Set radius based on the random values of x, y and z\nsampler = DependentSampler(depends=[ x ,  y ,  z ], formula= sqrt(x^2+y^2+z^2) )", 
            "title": "DependentSampler"
        }, 
        {
            "location": "/grading_math/sampling/#function-sampling", 
            "text": "When a random function can be specified, we need a sampling set that returns a random function on demand.", 
            "title": "Function Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#specificfunctions", 
            "text": "Samples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set.  # Select either sin or cos randomly\nfunctionsampler = SpecificFunctions([np.cos, np.sin])\n# Always select a single lambda function\nfunctionsampler = SpecificFunctions(lambda x: x*x)", 
            "title": "SpecificFunctions"
        }, 
        {
            "location": "/grading_math/sampling/#randomfunction", 
            "text": "Generate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude.  # Generate a random function\nfunctionsampler = RandomFunction(center=1, amplitude=2)\n# The default is center=0, amplitude=10\nfunctionsampler = RandomFunction()  You can control how many random sinusoids are added together by specifying  num_terms .  # Generate a random sinusoid\nfunctionsampler = RandomFunction(num_terms=1)  You can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension.  # Generate a function that takes in two values and outputs a 3D vector\nfunctionsampler = RandomFunction(input_dim=2, output_dim=3)   FormulaGrader and NumericalGrader  Home", 
            "title": "RandomFunction"
        }, 
        {
            "location": "/grading_math/renderer/", 
            "text": "AsciiMath Renderer Definitions\n\n\nWhen math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview:\n\n\nformulaequationinput/\n\nor\n\ntextline math=\n1\n/\n\n\n\n\n\nThe \nformulaequationinput\n tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from \nformulaequationinput\n is better than that of \ntextline\n, as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to \nformulaequationinput\n are that it doesn't recognize vectors such as \nvecx\n or \nhatx\n, the factorial and conjugation functions just apply as \nfact(x)\n and \nconj(x)\n, and because the processing is done server-side, we are unable to enhance the display at all.\n\n\nThe \ntextline\n tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in \n1/arctanh(x)\n in textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews.\n\n\nThis article describes how to use our new AsciiMath renderer definitions with a \ntextline\n tag.\n\n\nHow it works\n\n\nThe renderer definitions are located in a javascript file, \nMJxPrep.js\n, which should be uploaded to the static assets folder for your course. This javascript file loads two components: symbol definitions and a preprocessor.\n\n\nThe symbol definitions are used to teach AsciiMath how to display various functions properly, such as \nre\n, \nim\n, \narctanh\n etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem.\n\n\nscript type=\ntext/javascript\n src=\n/static/MJxPrep.js\n/script\n\n\n\n\n\nSome functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions are \nlog10\n, \nlog2\n, \nfact\n and \nfactorial\n. To use these, you need to add \npreprocessorClassName\n and \npreprocessorSrc\n properties to any textline tags that use the preprocessor.\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline correct_answer=\n1/fact(5)\n math=\n1\n preprocessorClassName=\nMJxPrep\n preprocessorSrc=\n/static/MJxPrep.js\n/\n\n\n/customresponse\n\n\n\n\n\nIf you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately).\n\n\nNotes\n\n\n\n\n\n\nNote that you don't need to use the grading library to take advantage of the symbol definitions and/or the preprocessor; they work just as well for the normal edX \nformularesponse\n problems!\n\n\n\n\n\n\nThe javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many \ntextline\n boxes as you like.\n\n\n\n\n\n\nIf you have a display issue with AsciiMath, it's likely that you can extend the symbol definitions and preprocessor to make your expressions display nicely for students.\n\n\n\n\n\n\nThe \nfunction listing\n article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.", 
            "title": "AsciiMath Renderer Definitions"
        }, 
        {
            "location": "/grading_math/renderer/#asciimath-renderer-definitions", 
            "text": "When math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview:  formulaequationinput/ \nor textline math= 1 /   The  formulaequationinput  tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from  formulaequationinput  is better than that of  textline , as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to  formulaequationinput  are that it doesn't recognize vectors such as  vecx  or  hatx , the factorial and conjugation functions just apply as  fact(x)  and  conj(x) , and because the processing is done server-side, we are unable to enhance the display at all.  The  textline  tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in  1/arctanh(x)  in textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews.  This article describes how to use our new AsciiMath renderer definitions with a  textline  tag.", 
            "title": "AsciiMath Renderer Definitions"
        }, 
        {
            "location": "/grading_math/renderer/#how-it-works", 
            "text": "The renderer definitions are located in a javascript file,  MJxPrep.js , which should be uploaded to the static assets folder for your course. This javascript file loads two components: symbol definitions and a preprocessor.  The symbol definitions are used to teach AsciiMath how to display various functions properly, such as  re ,  im ,  arctanh  etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem.  script type= text/javascript  src= /static/MJxPrep.js /script   Some functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions are  log10 ,  log2 ,  fact  and  factorial . To use these, you need to add  preprocessorClassName  and  preprocessorSrc  properties to any textline tags that use the preprocessor.  customresponse cfn= grader \n     textline correct_answer= 1/fact(5)  math= 1  preprocessorClassName= MJxPrep  preprocessorSrc= /static/MJxPrep.js /  /customresponse   If you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately).", 
            "title": "How it works"
        }, 
        {
            "location": "/grading_math/renderer/#notes", 
            "text": "Note that you don't need to use the grading library to take advantage of the symbol definitions and/or the preprocessor; they work just as well for the normal edX  formularesponse  problems!    The javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many  textline  boxes as you like.    If you have a display issue with AsciiMath, it's likely that you can extend the symbol definitions and preprocessor to make your expressions display nicely for students.    The  function listing  article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.", 
            "title": "Notes"
        }, 
        {
            "location": "/grading_lists/list_grader/", 
            "text": "ListGrader\n\n\nA \nListGrader\n is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast, \nSingleListGrader\n can be used to grade a list of items entered all at once into a single answer box.) ListGraders work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student.\n\n\nBasic usage\n\n\nIn this example, each input is checked against the corresponding answer, using \nStringGrader\n as the subgrader.\n\n\ngrader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader()\n)\n\n\n\n\nEach element of answers is set as an answer that is passed as the answers key into the subgrader. This should be set up as two input boxes that the student types in.\n\n\nIn the above example, the item grader just sees single strings as the answer. You can do more complicated things though, like the following.\n\n\nanswer1 = (\n    {'expect': 'zebra', 'grade_decimal': 1},\n    {'expect': 'horse', 'grade_decimal': 0.45},\n    {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'Unicorn? Really?'}\n)\nanswer2 = (\n    {'expect': 'cat', 'grade_decimal': 1},\n    {'expect': 'feline', 'grade_decimal': 0.5}\n)\ngrader = ListGrader(\n    answers=[answer1, answer2],\n    subgraders=StringGrader()\n)\n\n\n\n\nIn this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while \ncat\n and \nunicorn\n will get the unicorn message (and 1/2 points), \nzebra\n and \nunicorn\n will not (and also get 1/2 points).\n\n\nOrdered Input\n\n\nBy default, the ListGrader doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set ordered to True.\n\n\ngrader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader(),\n    ordered=True\n)\n\n\n\n\nNow, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none.\n\n\nMultiple Graders\n\n\nIf you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set ordered to True when using a list of subgraders.\n\n\ngrader = ListGrader(\n    answers=['cat', 'x^2+1'],\n    subgraders=[StringGrader(), FormulaGrader(variables=[\nx\n])],\n    ordered=True\n)\n\n\n\n\nSingleListGraders in ListGrader\n\n\nSome questions will require nested list graders. Simple versions can make use of a \nSingleListGrader\n subgrader, as in the following example.\n\n\nConsider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem.\n\n\ngrader = ListGrader(\n    answers=[\n        ['2', '4'],\n        ['1', '3']\n    ],\n    subgraders=SingleListGrader(\n        subgrader=NumericalGrader()\n    ),\n    ordered=True\n)\n\n\n\n\nThe nested \nSingleListGrader\n will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3.\n\n\nGrouped Inputs\n\n\nIf you find yourself wanting to nest ListGraders, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question.\n\n\ngrader = ListGrader(\n    answers=[\n        ['cat', '1'],\n        ['dog', '2'],\n        ['tiger', '3']\n    ],\n    subgraders=ListGrader(\n        subgraders=[StringGrader(), NumericalGrader()],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2, 3, 3]\n)\n\n\n\n\nIn this case, the second level of grader is receiving multiple inputs, and so itself needs to be a ListGrader. The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader (StringGrader and NumericalGrader) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the \nListGrader\n will find the optimal ordering of (animal, number) pairs.\n\n\nThe grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements.\n\n\nHere is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a \nListGrader\n for the first grouping, and a \nStringGrader\n for the second. Note that the first entry in answers is a list that is passed directly into the \nListGrader\n, while the second entry is just a string. This second-level \nListGrader\n is unordered.\n\n\ngrader = ListGrader(\n    answers=[\n        ['bat', 'ghost', 'pumpkin'],\n        'Halloween'\n    ],\n    subgraders=[\n        ListGrader(\n            subgraders=StringGrader()\n        ),\n        StringGrader()\n    ],\n    ordered=True,\n    grouping=[1, 1, 1, 2]\n)\n\n\n\n\nOur last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them.\n\n\ngrader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            SingleListGrader(\n                subgrader=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2]\n)\n\n\n\n\nThis example has four input boxes, with the first and third being graded by a \nNumericalGrader\n, and the second and fourth being graded by a \nSingleListGrader\n.\n\n\nIt is possible to specify a grouping on a nested \nListGrader\n. The outer \nListGrader\n must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components.\n\n\ngrader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            ListGrader(\n                subgraders=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True,\n        grouping=[1, 2, 2]\n    ),\n    grouping=[1, 1, 1, 2, 2, 2]\n)\n\n\n\n\nOption Listing\n\n\nHere is the full list of options specific to a \nListGrader\n.\n\n\ngrader = ListGrader(\n    answers=list,\n    subgraders=AbstractGrader or list of AbstractGraders,\n    ordered=bool, (default False)\n    grouping=list\n)\n\n\n\n\n\n\nHome", 
            "title": "ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#listgrader", 
            "text": "A  ListGrader  is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast,  SingleListGrader  can be used to grade a list of items entered all at once into a single answer box.) ListGraders work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student.", 
            "title": "ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#basic-usage", 
            "text": "In this example, each input is checked against the corresponding answer, using  StringGrader  as the subgrader.  grader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader()\n)  Each element of answers is set as an answer that is passed as the answers key into the subgrader. This should be set up as two input boxes that the student types in.  In the above example, the item grader just sees single strings as the answer. You can do more complicated things though, like the following.  answer1 = (\n    {'expect': 'zebra', 'grade_decimal': 1},\n    {'expect': 'horse', 'grade_decimal': 0.45},\n    {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'Unicorn? Really?'}\n)\nanswer2 = (\n    {'expect': 'cat', 'grade_decimal': 1},\n    {'expect': 'feline', 'grade_decimal': 0.5}\n)\ngrader = ListGrader(\n    answers=[answer1, answer2],\n    subgraders=StringGrader()\n)  In this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while  cat  and  unicorn  will get the unicorn message (and 1/2 points),  zebra  and  unicorn  will not (and also get 1/2 points).", 
            "title": "Basic usage"
        }, 
        {
            "location": "/grading_lists/list_grader/#ordered-input", 
            "text": "By default, the ListGrader doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set ordered to True.  grader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader(),\n    ordered=True\n)  Now, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none.", 
            "title": "Ordered Input"
        }, 
        {
            "location": "/grading_lists/list_grader/#multiple-graders", 
            "text": "If you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set ordered to True when using a list of subgraders.  grader = ListGrader(\n    answers=['cat', 'x^2+1'],\n    subgraders=[StringGrader(), FormulaGrader(variables=[ x ])],\n    ordered=True\n)", 
            "title": "Multiple Graders"
        }, 
        {
            "location": "/grading_lists/list_grader/#singlelistgraders-in-listgrader", 
            "text": "Some questions will require nested list graders. Simple versions can make use of a  SingleListGrader  subgrader, as in the following example.  Consider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem.  grader = ListGrader(\n    answers=[\n        ['2', '4'],\n        ['1', '3']\n    ],\n    subgraders=SingleListGrader(\n        subgrader=NumericalGrader()\n    ),\n    ordered=True\n)  The nested  SingleListGrader  will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3.", 
            "title": "SingleListGraders in ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#grouped-inputs", 
            "text": "If you find yourself wanting to nest ListGraders, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question.  grader = ListGrader(\n    answers=[\n        ['cat', '1'],\n        ['dog', '2'],\n        ['tiger', '3']\n    ],\n    subgraders=ListGrader(\n        subgraders=[StringGrader(), NumericalGrader()],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2, 3, 3]\n)  In this case, the second level of grader is receiving multiple inputs, and so itself needs to be a ListGrader. The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader (StringGrader and NumericalGrader) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the  ListGrader  will find the optimal ordering of (animal, number) pairs.  The grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements.  Here is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a  ListGrader  for the first grouping, and a  StringGrader  for the second. Note that the first entry in answers is a list that is passed directly into the  ListGrader , while the second entry is just a string. This second-level  ListGrader  is unordered.  grader = ListGrader(\n    answers=[\n        ['bat', 'ghost', 'pumpkin'],\n        'Halloween'\n    ],\n    subgraders=[\n        ListGrader(\n            subgraders=StringGrader()\n        ),\n        StringGrader()\n    ],\n    ordered=True,\n    grouping=[1, 1, 1, 2]\n)  Our last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them.  grader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            SingleListGrader(\n                subgrader=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2]\n)  This example has four input boxes, with the first and third being graded by a  NumericalGrader , and the second and fourth being graded by a  SingleListGrader .  It is possible to specify a grouping on a nested  ListGrader . The outer  ListGrader  must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components.  grader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            ListGrader(\n                subgraders=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True,\n        grouping=[1, 2, 2]\n    ),\n    grouping=[1, 1, 1, 2, 2, 2]\n)", 
            "title": "Grouped Inputs"
        }, 
        {
            "location": "/grading_lists/list_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  ListGrader .  grader = ListGrader(\n    answers=list,\n    subgraders=AbstractGrader or list of AbstractGraders,\n    ordered=bool, (default False)\n    grouping=list\n)   Home", 
            "title": "Option Listing"
        }, 
        {
            "location": "/grading_lists/single_list_grader/", 
            "text": "SingleListGrader\n\n\nIf you want a response to be a delimiter-separated list of items, you can use a special ItemGrader called \nSingleListGrader\n to perform the grading. You need to specify a subgrader (which must be an ItemGrader, and could even be another SingleListGrader) to evaluate each individual item. The basic usage is as follows.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader()\n)\n\n\n\n\nTo receive full points for this problem, a student would enter \ncat, dog\n or \ndog, cat\n into the input box. Entering \ncat, octopus\n or just \ncat\n will receive half points.\n\n\nYou can use a tuple of lists to specify multiple lists of answers, just like normal ItemGraders.\n\n\ngrader = SingleListGrader(\n    answers=(\n        [('cat', 'feline'), 'dog'],\n        ['goat', 'vole'],\n    ),\n    subgrader=StringGrader()\n)\n\n\n\n\nNow, \ncat, dog\n and \ngoat, vole\n will get full grades. But mixes won't: \ncat, vole\n will score half credit.\n\n\nOrdered Input\n\n\nBy default a SingleListGrader doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set \nordered=True\n.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    ordered=True\n)\n\n\n\n\nNow \ncat, dog\n will receive full grades, but \ndog, cat\n will be marked wrong. Note that \ncat\n will receive half credit, but \ndog\n will receive zero, as dog is incorrect in the first position. Ordered is false by default.\n\n\nLength Checking\n\n\nIf students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    length_error=True\n)\n\n\n\n\nIf you give this \ncat\n, it will tell you that you've got the wrong length, and won't use up an attempt.\n\n\nLength_error is false by default. If you set length_error to True, then all answers in a tuple of lists (rather than a single answer list) must have the same length.\n\n\nChoosing Delimiters\n\n\nYou can use whatever delimiter you like. The default is a comma (\n,\n). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    delimiter=';'\n)\n\n\n\n\nBy using different delimiters, it is possible to nest SingleListGraders:\n\n\ngrader = SingleListGrader(\n    answers=[['a', 'b'], ['c', 'd']],\n    subgrader=SingleListGrader(\n        subgrader=StringGrader()\n    ),\n    delimiter=';'\n)\n\n\n\n\nHere the expected student input is \na, b; c, d\n. It will also take \nb, a; d, c\n or \nc, d; a, b\n due to the unordered nature of both lists. However, \na, c; d, b\n is only worth half points.\n\n\nTurning Partial Credit Off\n\n\nBy default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set partial_credit to False. It is True by default.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    partial_credit=False\n)\n\n\n\n\nNow \ncat, octopus\n will receive a grade of zero.\n\n\nMessages\n\n\nMessages from the individual items are all concatenated together and presented to the student. It is also possible to have a \nwrong_msg\n on the \nSingleListGrader\n, which is presented to the student if the score is zero and there are no other messages, just like on an \nItemGrader\n.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    wrong_msg='Try again!'\n)\n\n\n\n\nOption Listing\n\n\nHere is the full list of options specific to a \nSingleListGrader\n.\n\n\ngrader = SingleListGrader(\n    answers=list or tuple of lists,\n    subgrader=ItemGrader(),\n    partial_credit=bool (default True),\n    ordered=bool (default False),\n    length_error=bool (default False),\n    delimiter=string (default ',')\n)\n\n\n\n\n\n\nHome", 
            "title": "SingleListGrader"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#singlelistgrader", 
            "text": "If you want a response to be a delimiter-separated list of items, you can use a special ItemGrader called  SingleListGrader  to perform the grading. You need to specify a subgrader (which must be an ItemGrader, and could even be another SingleListGrader) to evaluate each individual item. The basic usage is as follows.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader()\n)  To receive full points for this problem, a student would enter  cat, dog  or  dog, cat  into the input box. Entering  cat, octopus  or just  cat  will receive half points.  You can use a tuple of lists to specify multiple lists of answers, just like normal ItemGraders.  grader = SingleListGrader(\n    answers=(\n        [('cat', 'feline'), 'dog'],\n        ['goat', 'vole'],\n    ),\n    subgrader=StringGrader()\n)  Now,  cat, dog  and  goat, vole  will get full grades. But mixes won't:  cat, vole  will score half credit.", 
            "title": "SingleListGrader"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#ordered-input", 
            "text": "By default a SingleListGrader doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set  ordered=True .  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    ordered=True\n)  Now  cat, dog  will receive full grades, but  dog, cat  will be marked wrong. Note that  cat  will receive half credit, but  dog  will receive zero, as dog is incorrect in the first position. Ordered is false by default.", 
            "title": "Ordered Input"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#length-checking", 
            "text": "If students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    length_error=True\n)  If you give this  cat , it will tell you that you've got the wrong length, and won't use up an attempt.  Length_error is false by default. If you set length_error to True, then all answers in a tuple of lists (rather than a single answer list) must have the same length.", 
            "title": "Length Checking"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#choosing-delimiters", 
            "text": "You can use whatever delimiter you like. The default is a comma ( , ). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    delimiter=';'\n)  By using different delimiters, it is possible to nest SingleListGraders:  grader = SingleListGrader(\n    answers=[['a', 'b'], ['c', 'd']],\n    subgrader=SingleListGrader(\n        subgrader=StringGrader()\n    ),\n    delimiter=';'\n)  Here the expected student input is  a, b; c, d . It will also take  b, a; d, c  or  c, d; a, b  due to the unordered nature of both lists. However,  a, c; d, b  is only worth half points.", 
            "title": "Choosing Delimiters"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#turning-partial-credit-off", 
            "text": "By default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set partial_credit to False. It is True by default.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    partial_credit=False\n)  Now  cat, octopus  will receive a grade of zero.", 
            "title": "Turning Partial Credit Off"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#messages", 
            "text": "Messages from the individual items are all concatenated together and presented to the student. It is also possible to have a  wrong_msg  on the  SingleListGrader , which is presented to the student if the score is zero and there are no other messages, just like on an  ItemGrader .  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    wrong_msg='Try again!'\n)", 
            "title": "Messages"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  SingleListGrader .  grader = SingleListGrader(\n    answers=list or tuple of lists,\n    subgrader=ItemGrader(),\n    partial_credit=bool (default True),\n    ordered=bool (default False),\n    length_error=bool (default False),\n    delimiter=string (default ',')\n)   Home", 
            "title": "Option Listing"
        }
    ]
}