{
    "docs": [
        {
            "location": "/", 
            "text": "MITx Grading Library Documentation\n # \n\n\nThis documentation describes how to use the grading library. In particular, it goes through the syntax required to construct each of the different types of graders.\n\n\nFor information on installation and how to use the library in edX, see \nGetting Started\n.\n\n\nOverview\n # \n\n\nThe basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general.\n\n\nUsing Grading Classes\n # \n\n\nAll grading classes are instantiated by calling them. Here, \nGradingClass\n is a generic grading class (\nGradingClass\n does not actually exist).\n\n\ngrader = GradingClass(options)\n\n\n\n\nThe options provided to a grading class may be passed in directly, as\n\n\ngrader = GradingClass(name='value')\n\n\n\n\nYou can also pass in a configuration dictionary. This may be helpful if using the same configuration for multiple problems.\n\n\noptions = {'name': 'value'}\ngrader = GradingClass(options)\n\n\n\n\nYou cannot 'mix and match' these two options. If a configuration dictionary is supplied, any keyword arguments are ignored.\n\n\nOptions\n # \n\n\nThe options passed to a grading class undergo extensive validation and graders will throw\nerrors if instantiated with invalid options.\n\n\nA few error messages serve only as warnings (e.g., that you are attempting to override a default constant like \npi\n). These warning errors can be suppressed by setting\n\n\ngrader = GradingClass(suppress_warnings=True)\n\n\n\n\nEvery grading class also has a debug option. By default, \ndebug=False\n. To receive debug information from a given grader, specify \ndebug=True\n. Some graders will provide more debug information than others.\n\n\ngrader = GradingClass(debug=True)\n\n\n\n\nAll other options are specific to the grading class in question.\n\n\nGrading Classes\n # \n\n\nGrading classes generally fall into two categories: single-input graders and multi-input graders.\n\n\nAll graders that grade a single input are built on a framework we call an ItemGrader. We recommend understanding how ItemGraders work before diving into more specifics. We provide a number of graders built off ItemGrader. A special type of ItemGrader is SingleListGrader, which lets you grade a delimiter-separated list of inputs in a single response.\n\n\nMulti-input graders that are just composed of single-input graders working in concert can be handled by the general ListGrader class. At this stage, ListGrader is the only multi-input grader included in the library, although plugins can be used to construct further examples.\n\n\n\n\nItemGrader\n\n\nStringGrader\n\n\nFormulaGrader\n\n\nNumericalGrader\n\n\nSingleListGrader\n\n\nListGrader\n\n\n\n\nPlugins\n # \n\n\nAny .py file stored in the \nplugins\n folder will be automatically loaded. All variables in the \nall\n list will be made available when doing \nfrom mitxgraders import *\n. See \ntemplate.py\n for an example.\n\n\nYou can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from \nstringgrader.py\n, renaming the class, and building a simple plugin based on \nStringGrader\n.\n\n\nWe are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through \ngithub\n. We are also willing to consider incorporating good plugins into the library itself.", 
            "title": "Home"
        }, 
        {
            "location": "/#mitx-grading-library-documentation", 
            "text": "This documentation describes how to use the grading library. In particular, it goes through the syntax required to construct each of the different types of graders.  For information on installation and how to use the library in edX, see  Getting Started .", 
            "title": "MITx Grading Library Documentation"
        }, 
        {
            "location": "/#overview", 
            "text": "The basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general.", 
            "title": "Overview"
        }, 
        {
            "location": "/#using-grading-classes", 
            "text": "All grading classes are instantiated by calling them. Here,  GradingClass  is a generic grading class ( GradingClass  does not actually exist).  grader = GradingClass(options)  The options provided to a grading class may be passed in directly, as  grader = GradingClass(name='value')  You can also pass in a configuration dictionary. This may be helpful if using the same configuration for multiple problems.  options = {'name': 'value'}\ngrader = GradingClass(options)  You cannot 'mix and match' these two options. If a configuration dictionary is supplied, any keyword arguments are ignored.", 
            "title": "Using Grading Classes"
        }, 
        {
            "location": "/#options", 
            "text": "The options passed to a grading class undergo extensive validation and graders will throw\nerrors if instantiated with invalid options.  A few error messages serve only as warnings (e.g., that you are attempting to override a default constant like  pi ). These warning errors can be suppressed by setting  grader = GradingClass(suppress_warnings=True)  Every grading class also has a debug option. By default,  debug=False . To receive debug information from a given grader, specify  debug=True . Some graders will provide more debug information than others.  grader = GradingClass(debug=True)  All other options are specific to the grading class in question.", 
            "title": "Options"
        }, 
        {
            "location": "/#grading-classes", 
            "text": "Grading classes generally fall into two categories: single-input graders and multi-input graders.  All graders that grade a single input are built on a framework we call an ItemGrader. We recommend understanding how ItemGraders work before diving into more specifics. We provide a number of graders built off ItemGrader. A special type of ItemGrader is SingleListGrader, which lets you grade a delimiter-separated list of inputs in a single response.  Multi-input graders that are just composed of single-input graders working in concert can be handled by the general ListGrader class. At this stage, ListGrader is the only multi-input grader included in the library, although plugins can be used to construct further examples.   ItemGrader  StringGrader  FormulaGrader  NumericalGrader  SingleListGrader  ListGrader", 
            "title": "Grading Classes"
        }, 
        {
            "location": "/#plugins", 
            "text": "Any .py file stored in the  plugins  folder will be automatically loaded. All variables in the  all  list will be made available when doing  from mitxgraders import * . See  template.py  for an example.  You can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from  stringgrader.py , renaming the class, and building a simple plugin based on  StringGrader .  We are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through  github . We are also willing to consider incorporating good plugins into the library itself.", 
            "title": "Plugins"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Getting Started\n # \n\n\nUsage in edX\n # \n\n\nDownload \npython_lib.zip\n and place it in your static folder (XML workflow) or upload it as a file asset (Studio workflow). If you already have a python_lib.zip, you'll need to merge ours with yours and re-zip. If you want to use our AsciiMath renderer definitions, place the \nMjxPrep.js\n file in your static folder (XML) or upload the file to your course (Studio).\n\n\nMITxGraders: Reusable CustomResponse Check Functions\n # \n\n\nA custom response problem is defined using the \ncustomresponse\n tag. It needs to be supplied with a particular type of Python function that edX calls a check function (or \"cfn\"). The mitxgraders library provides reusable check functions. The basic usage pattern is:\n\n\nscript type=\ntext/python\n system_path=\npython_lib\n\nfrom mitxgraders import *\ngrader = GraderType(\n    [configuration]\n)\n\n/script\n\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline/\n\n\n/customresponse\n\n\n\n\n\nThe configuration depends on the type of grader that you're using. Note that all answers must be passed through the configuration. In particular, the \nexpect\n  attribute on \ncustomresponse\n tag is ignored by our graders (but can be used to display an answer string to students).\n\n\nHere is an example where we use a StringGrader with answer \ncat\n.\n\n\nscript type=\ntext/python\n system_path=\npython_lib\n\nfrom mitxgraders import *\ngrader = StringGrader(\n    answers='cat'\n)\n\n/script\n\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline correct_answer=\ncat\n/\n\n\n/customresponse\n\n\n\n\n\nThe \nexpect\n keyword is ignored by the grader, but is shown when students click on \"Show Answer\". This works only for single-input problems.\n\n\nHere is another example where we use a ListGrader to grade two numbers in an unordered fashion.\n\n\nscript type=\ntext/python\n system_path=\npython_lib\n\nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['1', '2'],\n    subgraders=FormulaGrader()\n)\n\n/script\n\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline correct_answer=\n1\n/\n\n    \ntextline correct_answer=\n2\n/\n\n\n/customresponse\n\n\n\n\n\nHere, the \ncorrect_answer\n entries are shown to students when they click \"Show Answer\". These values are not provided to the grader. The \ncorrect_answer\n attributes can also be used for single-input problems.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#usage-in-edx", 
            "text": "Download  python_lib.zip  and place it in your static folder (XML workflow) or upload it as a file asset (Studio workflow). If you already have a python_lib.zip, you'll need to merge ours with yours and re-zip. If you want to use our AsciiMath renderer definitions, place the  MjxPrep.js  file in your static folder (XML) or upload the file to your course (Studio).", 
            "title": "Usage in edX"
        }, 
        {
            "location": "/getting_started/#mitxgraders-reusable-customresponse-check-functions", 
            "text": "A custom response problem is defined using the  customresponse  tag. It needs to be supplied with a particular type of Python function that edX calls a check function (or \"cfn\"). The mitxgraders library provides reusable check functions. The basic usage pattern is:  script type= text/python  system_path= python_lib \nfrom mitxgraders import *\ngrader = GraderType(\n    [configuration]\n) /script  customresponse cfn= grader \n     textline/  /customresponse   The configuration depends on the type of grader that you're using. Note that all answers must be passed through the configuration. In particular, the  expect   attribute on  customresponse  tag is ignored by our graders (but can be used to display an answer string to students).  Here is an example where we use a StringGrader with answer  cat .  script type= text/python  system_path= python_lib \nfrom mitxgraders import *\ngrader = StringGrader(\n    answers='cat'\n) /script  customresponse cfn= grader \n     textline correct_answer= cat /  /customresponse   The  expect  keyword is ignored by the grader, but is shown when students click on \"Show Answer\". This works only for single-input problems.  Here is another example where we use a ListGrader to grade two numbers in an unordered fashion.  script type= text/python  system_path= python_lib \nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['1', '2'],\n    subgraders=FormulaGrader()\n) /script  customresponse cfn= grader \n     textline correct_answer= 1 / \n     textline correct_answer= 2 /  /customresponse   Here, the  correct_answer  entries are shown to students when they click \"Show Answer\". These values are not provided to the grader. The  correct_answer  attributes can also be used for single-input problems.", 
            "title": "MITxGraders: Reusable CustomResponse Check Functions"
        }, 
        {
            "location": "/item_grader/", 
            "text": "ItemGrader\n # \n\n\nWhen an individual input needs to be graded, it is graded by an item grader. All item graders work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use \nStringGrader\n as an example of how to use a generic ItemGrader. You cannot use a generic ItemGrader by itself.\n\n\ngrader = StringGrader(\n    answers='cat',\n    wrong_msg='Try again!'\n)\n\n\n\n\nThe \nanswers\n can be used to specify correct answers, specific feedback messages, and to assign partial credit. The \nanswers\n key accepts a few formats:\n\n\n\n\nA single dictionary can be used to specify an answer, feedback, correctness, and partial credit:\n\n\n\n\ngrader = StringGrader(\n    answers={'expect': 'zebra', 'ok': True, 'grade_decimal': 1, 'msg': 'Yay!'},\n    wrong_msg='Try again!'\n)\n\n\n\n\nThe answers dictionary keys are:\n  - \n'expect'\n (required): compared against student answer. Most ItemGraders use strings to specify the \n'expect'\n value.\n  - \n'grade_decimal'\n (a number between \n0\n and \n1\n): The partial credit associated with this answer; default value is \n1\n.\n  - \n'ok'\n (\nTrue\n, \nFalse\n, or \n'partial'\n): The answer's correctness; determines icon used by edX. The default value is inferred from \ngrade_decimal\n.\n  - \n'msg'\n (string): A feedback message associated with this answer.\n\n\n\n\nA single \n'expect'\n value: can be used to specify the correct answer. For example,\n\n\n\n\ngrader = StringGrader(\n    answers='cat',\n    # Equivalent to:\n    # answers={'expect': 'cat', 'msg': '', 'grade_decimal': 1, 'ok': True}\n    wrong_msg='Try again!'\n)\n\n\n\n\nAgain, most ItemGraders use strings to store \n'expect'\n values.\n\n\n\n\nA tuple of dictionaries or strings:\n\n\n\n\ngrader = StringGrader(\n    answers=(\n        # the correct answer\n        'wolf',\n        # an alternative correct answer\n        'canis lupus',\n        # a partially correct answer\n        {'expect': 'dog', 'grade_decimal': 0.5, 'msg': 'No, not dog!'},\n        # a wrong answer with specific feedback\n        {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'No, not unicorn!'}\n    ),\n    wrong_msg='Try again!'\n)\n\n\n\n\nInternally, the ItemGrader converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student.\n\n\nThe \nwrong_msg\n is only displayed if the score is zero, and there are no other messages.\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to an \nItemGrader\n.\n\n\ngrader = ItemGrader(\n    answers=answer or tuple of answers,\n    wrong_msg=string (default '')\n)", 
            "title": "ItemGrader"
        }, 
        {
            "location": "/item_grader/#itemgrader", 
            "text": "When an individual input needs to be graded, it is graded by an item grader. All item graders work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use  StringGrader  as an example of how to use a generic ItemGrader. You cannot use a generic ItemGrader by itself.  grader = StringGrader(\n    answers='cat',\n    wrong_msg='Try again!'\n)  The  answers  can be used to specify correct answers, specific feedback messages, and to assign partial credit. The  answers  key accepts a few formats:   A single dictionary can be used to specify an answer, feedback, correctness, and partial credit:   grader = StringGrader(\n    answers={'expect': 'zebra', 'ok': True, 'grade_decimal': 1, 'msg': 'Yay!'},\n    wrong_msg='Try again!'\n)  The answers dictionary keys are:\n  -  'expect'  (required): compared against student answer. Most ItemGraders use strings to specify the  'expect'  value.\n  -  'grade_decimal'  (a number between  0  and  1 ): The partial credit associated with this answer; default value is  1 .\n  -  'ok'  ( True ,  False , or  'partial' ): The answer's correctness; determines icon used by edX. The default value is inferred from  grade_decimal .\n  -  'msg'  (string): A feedback message associated with this answer.   A single  'expect'  value: can be used to specify the correct answer. For example,   grader = StringGrader(\n    answers='cat',\n    # Equivalent to:\n    # answers={'expect': 'cat', 'msg': '', 'grade_decimal': 1, 'ok': True}\n    wrong_msg='Try again!'\n)  Again, most ItemGraders use strings to store  'expect'  values.   A tuple of dictionaries or strings:   grader = StringGrader(\n    answers=(\n        # the correct answer\n        'wolf',\n        # an alternative correct answer\n        'canis lupus',\n        # a partially correct answer\n        {'expect': 'dog', 'grade_decimal': 0.5, 'msg': 'No, not dog!'},\n        # a wrong answer with specific feedback\n        {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'No, not unicorn!'}\n    ),\n    wrong_msg='Try again!'\n)  Internally, the ItemGrader converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student.  The  wrong_msg  is only displayed if the score is zero, and there are no other messages.", 
            "title": "ItemGrader"
        }, 
        {
            "location": "/item_grader/#option-listing", 
            "text": "Here is the full list of options specific to an  ItemGrader .  grader = ItemGrader(\n    answers=answer or tuple of answers,\n    wrong_msg=string (default '')\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/string_grader/", 
            "text": "StringGrader\n # \n\n\nThe StringGrader class does a letter-for-letter comparison of the student's answer with the expected answer. It is the simplest grading class, both in code and in usage.\n\n\nTo use a StringGrader, simply pass in the set of answers you want to grade, as described in the \nItemGrader documentation\n.\n\n\ngrader = StringGrader(\n    answers='cat'\n)\n\n\n\n\nThis will accept the answer of \ncat\n, but not \nCAT\n or \nCat\n, as grading is case-sensitive by default.\n\n\nCase Sensitive\n # \n\n\nTo perform case-insensitive grading, pass in the appropriate flag as follows.\n\n\ngrader = StringGrader(\n    answers='Cat',\n    case_sensitive=False\n)\n\n\n\n\nThis will accept \nCat\n, \ncat\n and \nCAT\n. By default, \ncase_sensitive=True\n.\n\n\nStripping Input\n # \n\n\nLeading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip.\n\n\ngrader = StringGrader(\n    answers='cat',\n    strip=False\n)\n\n\n\n\nThis will accept \ncat\n, but will reject answers with leading or trailing spaces. By default, \nstrip=True\n.\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to a \nStringGrader\n.\n\n\ngrader = SingleListGrader(\n    case_sensitive=bool (default True),\n    strip=bool (default False)\n)", 
            "title": "StringGrader"
        }, 
        {
            "location": "/string_grader/#stringgrader", 
            "text": "The StringGrader class does a letter-for-letter comparison of the student's answer with the expected answer. It is the simplest grading class, both in code and in usage.  To use a StringGrader, simply pass in the set of answers you want to grade, as described in the  ItemGrader documentation .  grader = StringGrader(\n    answers='cat'\n)  This will accept the answer of  cat , but not  CAT  or  Cat , as grading is case-sensitive by default.", 
            "title": "StringGrader"
        }, 
        {
            "location": "/string_grader/#case-sensitive", 
            "text": "To perform case-insensitive grading, pass in the appropriate flag as follows.  grader = StringGrader(\n    answers='Cat',\n    case_sensitive=False\n)  This will accept  Cat ,  cat  and  CAT . By default,  case_sensitive=True .", 
            "title": "Case Sensitive"
        }, 
        {
            "location": "/string_grader/#stripping-input", 
            "text": "Leading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip.  grader = StringGrader(\n    answers='cat',\n    strip=False\n)  This will accept  cat , but will reject answers with leading or trailing spaces. By default,  strip=True .", 
            "title": "Stripping Input"
        }, 
        {
            "location": "/string_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  StringGrader .  grader = SingleListGrader(\n    case_sensitive=bool (default True),\n    strip=bool (default False)\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/grading_math/formula_grader/", 
            "text": "FormulaGrader\n # \n\n\nFormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's \nformularesponse /\n tag, but with much more versatility.\n\n\n\n\nNote\n\n\n\n\nAll expressions are treated in a case sensitive manner. This means that variables \n'm'\n and \n'M'\n are distinct. Case-insensitive FormulaGraders were deprecated in \nVersion 1.1.0\n\n\nAll whitespace is stripped from formulas that are entered. So, \n1 + x ^ 2\n is equivalent to \n1+x^2\n.\n\n\n\n\n\n\nVariables and Sampling\n # \n\n\nFormulaGrader grades a formula by numerical sampling. That is, random values are  assigned to each of the unknown variables and unknown functions, then the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.\n\n\nVariables are configured by including a list of strings of each variable name as follows.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2+y',\n    variables=['x', 'y']\n)\n\n\n\n\nNote that the \nanswers\n parameter follows all of the usual allowances from ItemGrader.\n\n\nThe variables need to have numbers randomly assigned to them. Each is sampled from a \nsampling set\n, which is RealInterval() by default (random numbers from 1 to 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the \nsample_from\n key.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2+y+z/2',\n    variables=['x', 'y', 'z'],\n    sample_from={\n        'x': ComplexRectangle(),\n        'y': [2, 6],\n        'z': (1, 3, 4, 8)\n    }\n)\n\n\n\n\nThe \nsample_from\n key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.\n\n\nNumbered Variables\n # \n\n\nYou can also specify special variables that are numbered. For example, if you specify that \na\n is a numbered variable, students can include \na_{0}\n, \na_{5}\n, \na_{-2}\n, etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.\n\n\ngrader = FormulaGrader(\n    answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n    variables=['x'],\n    numbered_vars=['a'],\n    sample_from={\n        'x': [-5, 5],\n        'a': [-10, 10]\n    }\n)\n\n\n\n\nIf you have a variable name that would clash with a numbered variable (say, you defined \na_{0}\n and also a numbered variable \na\n), then the specific variable has precedence.\n\n\nSamples and Failable Evaluations\n # \n\n\nTo control the number of samples that are checked to ensure correctness, you can modify the \nsamples\n key.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10\n)\n\n\n\n\nThe default for \nsamples\n is 5.\n\n\nYou may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set \nfailable_evals\n. This should be used very sparingly!\n\n\ngrader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10,\n    failable_evals=1\n)\n\n\n\n\nFunctions\n # \n\n\nBy default, a large array of mathematical functions are available for use. See the full list \nhere\n. Note that functions for manipulating complex variables are available, which allows you to grade complex expressions. In the following example, \nz*z\n is recognized to be different from \nabs(z)^2\n.\n\n\ngrader = FormulaGrader(\n    answers='abs(z)^2',\n    variables=['z'],\n    sample_from={\n        'z': ComplexRectangle()\n    }\n)\n\n\n\n\nUser Functions\n # \n\n\nYou can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the \nuser_functions\n key as follows.\n\n\ngrader = FormulaGrader(\n    answers='x*x',\n    variables=['x'],\n    user_functions={'f': lambda x: x*x}\n)\n\n\n\n\nThis defines a function \nf(x) = x^2\n. User-defined function names must start with a letter, and can use numbers and underscores, such as \nmy_func2\n. They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg, \nf''\n. Be careful about using quotation marks appropriately when using primes in function names!\n\n\ngrader = FormulaGrader(\n    answers=\nf''(x)\n,\n    variables=['x'],\n    user_functions={\nf''\n: lambda x: x*x}\n)\n\n\n\n\nYou can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.\n\n\ngrader = FormulaGrader(\n    answers=\nf(x)\n,\n    variables=['x'],\n    user_functions={\nf\n: [np.sin, np.cos]}\n)\n\n\n\n\nEach time this formula is checked, the function \nf\n will be sampled from the list of available functions.\n\n\nYou can also specify a random well-behaved function by using the RandomFunction() sampling set.\n\n\ngrader = FormulaGrader(\n    answers=\nf''(x) + omega^2*f(x)\n,\n    variables=['x', 'omega'],\n    user_functions={\n        \nf\n: RandomFunction(),\n        \nf''\n: RandomFunction()\n    }\n)\n\n\n\n\nThis allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example.\n\n\nConstants\n # \n\n\nBy default, four constants are defined: \ne\n, \npi\n, and \ni=j=sqrt(-1)\n. You can define new constants by passing in a dictionary to \nuser_constants\n as follows.\n\n\ngrader = FormulaGrader(\n    answers='1/sqrt(1-v^2/c^2)',\n    variables=['v'],\n    user_constants={\n        'c': 3e8\n    }\n)\n\n\n\n\nConstants are like variables that only ever have one value.\n\n\nOverriding Default Functions and Constants\n # \n\n\nYou can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with \nsuppress_warnings=True\n. The grader\n\n\ngrader = FormulaGrader(\n    answers='x^2',\n    variables=['x'],\n    user_functions={'sin': lambda x: x*x},\n)\n\n\n\n\nwill raise an error\n\n\n\n\nConfigError: Warning: 'user_functions' contains entries '['sin']' which will override default values. If you intend to override to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.\n\n\n\n\nThe error can be suppressed by setting \nsuppress_warnings=True\n.\n\n\nRestricting Student Input\n # \n\n\nFor some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand \nsin(2*theta)\n, then you don't want students to be able to just write \nsin(2*theta)\n and be graded correct.\n\n\nFormulaGrader offers a few ways to restrict what sort of answers will be marked correct.\n\n\nForbidden Strings\n # \n\n\nYou can forbid students from entering certain strings using the \nforbidden_strings\n key:\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n    forbidden_message=\nYour answer should only use trigonometric functions acting on theta, not multiples of theta\n\n)\n\n\n\n\nIf a student tries to use one of these strings, then they receive the \nforbidden_message\n, without giving away what the forbidden string is. We recommend using this sparingly, as students will find it confusing. The default \nforbidden_message\n is \"Invalid Input: This particular answer is forbidden\".\n\n\nForbidden strings and student answers are stripped of whitespace before being compared. Thus, if \nx + y\n is forbidden, then answers containing \nx+y\n or \nx   +   y\n will be rejected.\n\n\nBlacklists and Whitelists\n # \n\n\nYou can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example, \nsin\n is disallowed in correct answers.\n\n\ngrader = FormulaGrader(\n    answers='sqrt(1 - cos(x)^2)',\n    variables=['x'],\n    sample_from={'x': [0, np.pi]},\n    blacklist=['sin']\n)\n\n\n\n\nIf you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos.\n\n\ngrader = FormulaGrader(\n    answers='sin(x)/cos(x)',\n    variables=['x'],\n    whitelist=['sin', 'cos']\n)\n\n\n\n\nIf you want to exclude all functions, use \nwhitelist=[None]\n:\n\n\ngrader = FormulaGrader(\n    answers='pi/2-x',\n    variables=['x'],\n    whitelist=[None] # no functions are allowed\n)\n\n\n\n\nYou cannot use a whitelist and a blacklist at the same time.\n\n\nRequired Functions\n # \n\n\nYou can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    required_functions=['sin', 'cos']\n)\n\n\n\n\nTolerance\n # \n\n\nStudent inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg, \n0.1\n) or a percentage (eg, \n\"0.01%\"\n, which is the default tolerance).  Tolerances must be nonnegative numbers or percentages.\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    tolerance=0.00001\n)\n\n\n\n\nTolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.\n\n\nSuffixes\n # \n\n\nNumbers with a % at the end will be treated as percentages, and converted to the appropriate decimals.\n\n\nedX also defines a number of metric suffixes (k, M, G, T, m, u, n, and p) that modify a number appropriately. However, in our experience, these metric suffixes lead to more confusion than use. For example, \n2M\n, which one would expect should be rejected as an error when \n2*M\n was intended, is accepted by edX, interpreted as \n2*10^6\n, marked incorrect, and eats a student's attempt. Similarly for all of the other metric suffixes.\n\n\nWe have therefore made the decision to disable metric suffixes by default. If you want to enable them, you can do so using the following.\n\n\ngrader = FormulaGrader(\n    answers='2*m',\n    variables=['m'],\n    metric_suffixes=True\n)\n\n\n\n\nWe strongly recommend \nnot\n doing this when using the following variable names: k, M, G, T, m, u, n, and p.\n\n\nComparer Functions\n # \n\n\nBy default, FormulaGrader compares the numerically sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. For example, if grading angles in degrees, it may be useful to compare formulas modulo 360.\n\n\nTo use an alternate comparer, specify the \nanswers\n key as a dictionary with keys \ncomparer\n and \ncomparer_params\n rather than a single string. For example, to compare formulas modulo 360:\n\n\ndef is_coterminal(comparer_params_evals, student_eval, utils):\n    answer = comparer_params_evals[0]\n    reduced = student_eval % (360)\n    return utils.within_tolerance(answer, reduced)\n\ngrader = FormulaGrader(\n    answers={\n        'comparer': is_coterminal,\n        'comparer_params': ['b^2/a'],\n    },\n    variables=['a', 'b'],\n    tolerance='1%'\n)\n\n\n\n\nThis grader would accept \n'b^2/a'\n as well as \n'b^2/a + 360'\n, \n'b^2/a + 720'\n, etc.\n\n\nIn the grader configuration, \ncomparer_params\n is a list of strings that are numerically evaluated and passed to the comparer function. The \ncomparer\n function is a user-specified function with signature \ncomparer(comparer_params_evals, student_eval, utils)\n. When \nFormulaGrader\n calls the comparer function, \ncomparer\n the argument values are:\n- \ncomparer_params_evals\n: The \ncomparer_params\n list, numerically evaluated according to variable and function sampling.\n- \nstudent_eval\n: The student's input, numerically evaluated according to variable and function sampling\n- \nutils\n: A convenience object that may be helpful when writing custom comparer functions. Has properties:\n  - \nutils.tolerance\n: The tolerance specified in grader configuration, \n0.01%\n by default\n  - \nutils.within_tolerance:\n A function with signature \nwithin_tolerance(x, y)\n which checks that \ny\n is within specified tolerance of \nx\n. Can handle scalars, vectors, and matrices. If tolerance was specified as a percentage, then checks that \n|x-y| \n tolerance * x\n.\n\n\nOther Improvements\n # \n\n\nWe have made a number of other improvements over the edX formula graders, including:\n\n\n\n\nSquare roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like \nsqrt(x-1)\n or \n(x-1)^0.5\n always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.\n\n\nOur parser uses a parsing cache, and hence runs much more efficiently than the edX graders.\n\n\nIf students input an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.\n\n\nWhen students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.\n\n\nSimilarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.\n\n\nIf an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the \ndebug\n flag to True, and a more technical message will usually be displayed.\n\n\nFull sampling details are included when the \ndebug\n flag is set to True.\n\n\nEnhancements to the AsciiMath renderer (the preview that students see when using \ntextline\n inputs) are available using our \nAsciiMath renderer definitions\n.", 
            "title": "FormulaGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#formulagrader", 
            "text": "FormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's  formularesponse /  tag, but with much more versatility.   Note   All expressions are treated in a case sensitive manner. This means that variables  'm'  and  'M'  are distinct. Case-insensitive FormulaGraders were deprecated in  Version 1.1.0  All whitespace is stripped from formulas that are entered. So,  1 + x ^ 2  is equivalent to  1+x^2 .", 
            "title": "FormulaGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#variables-and-sampling", 
            "text": "FormulaGrader grades a formula by numerical sampling. That is, random values are  assigned to each of the unknown variables and unknown functions, then the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.  Variables are configured by including a list of strings of each variable name as follows.  grader = FormulaGrader(\n    answers='1+x^2+y',\n    variables=['x', 'y']\n)  Note that the  answers  parameter follows all of the usual allowances from ItemGrader.  The variables need to have numbers randomly assigned to them. Each is sampled from a  sampling set , which is RealInterval() by default (random numbers from 1 to 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the  sample_from  key.  grader = FormulaGrader(\n    answers='1+x^2+y+z/2',\n    variables=['x', 'y', 'z'],\n    sample_from={\n        'x': ComplexRectangle(),\n        'y': [2, 6],\n        'z': (1, 3, 4, 8)\n    }\n)  The  sample_from  key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.", 
            "title": "Variables and Sampling"
        }, 
        {
            "location": "/grading_math/formula_grader/#numbered-variables", 
            "text": "You can also specify special variables that are numbered. For example, if you specify that  a  is a numbered variable, students can include  a_{0} ,  a_{5} ,  a_{-2} , etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.  grader = FormulaGrader(\n    answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n    variables=['x'],\n    numbered_vars=['a'],\n    sample_from={\n        'x': [-5, 5],\n        'a': [-10, 10]\n    }\n)  If you have a variable name that would clash with a numbered variable (say, you defined  a_{0}  and also a numbered variable  a ), then the specific variable has precedence.", 
            "title": "Numbered Variables"
        }, 
        {
            "location": "/grading_math/formula_grader/#samples-and-failable-evaluations", 
            "text": "To control the number of samples that are checked to ensure correctness, you can modify the  samples  key.  grader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10\n)  The default for  samples  is 5.  You may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set  failable_evals . This should be used very sparingly!  grader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10,\n    failable_evals=1\n)", 
            "title": "Samples and Failable Evaluations"
        }, 
        {
            "location": "/grading_math/formula_grader/#functions", 
            "text": "By default, a large array of mathematical functions are available for use. See the full list  here . Note that functions for manipulating complex variables are available, which allows you to grade complex expressions. In the following example,  z*z  is recognized to be different from  abs(z)^2 .  grader = FormulaGrader(\n    answers='abs(z)^2',\n    variables=['z'],\n    sample_from={\n        'z': ComplexRectangle()\n    }\n)", 
            "title": "Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#user-functions", 
            "text": "You can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the  user_functions  key as follows.  grader = FormulaGrader(\n    answers='x*x',\n    variables=['x'],\n    user_functions={'f': lambda x: x*x}\n)  This defines a function  f(x) = x^2 . User-defined function names must start with a letter, and can use numbers and underscores, such as  my_func2 . They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg,  f'' . Be careful about using quotation marks appropriately when using primes in function names!  grader = FormulaGrader(\n    answers= f''(x) ,\n    variables=['x'],\n    user_functions={ f'' : lambda x: x*x}\n)  You can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.  grader = FormulaGrader(\n    answers= f(x) ,\n    variables=['x'],\n    user_functions={ f : [np.sin, np.cos]}\n)  Each time this formula is checked, the function  f  will be sampled from the list of available functions.  You can also specify a random well-behaved function by using the RandomFunction() sampling set.  grader = FormulaGrader(\n    answers= f''(x) + omega^2*f(x) ,\n    variables=['x', 'omega'],\n    user_functions={\n         f : RandomFunction(),\n         f'' : RandomFunction()\n    }\n)  This allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example.", 
            "title": "User Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#constants", 
            "text": "By default, four constants are defined:  e ,  pi , and  i=j=sqrt(-1) . You can define new constants by passing in a dictionary to  user_constants  as follows.  grader = FormulaGrader(\n    answers='1/sqrt(1-v^2/c^2)',\n    variables=['v'],\n    user_constants={\n        'c': 3e8\n    }\n)  Constants are like variables that only ever have one value.", 
            "title": "Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#overriding-default-functions-and-constants", 
            "text": "You can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with  suppress_warnings=True . The grader  grader = FormulaGrader(\n    answers='x^2',\n    variables=['x'],\n    user_functions={'sin': lambda x: x*x},\n)  will raise an error   ConfigError: Warning: 'user_functions' contains entries '['sin']' which will override default values. If you intend to override to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.   The error can be suppressed by setting  suppress_warnings=True .", 
            "title": "Overriding Default Functions and Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#restricting-student-input", 
            "text": "For some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand  sin(2*theta) , then you don't want students to be able to just write  sin(2*theta)  and be graded correct.  FormulaGrader offers a few ways to restrict what sort of answers will be marked correct.", 
            "title": "Restricting Student Input"
        }, 
        {
            "location": "/grading_math/formula_grader/#forbidden-strings", 
            "text": "You can forbid students from entering certain strings using the  forbidden_strings  key:  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n    forbidden_message= Your answer should only use trigonometric functions acting on theta, not multiples of theta \n)  If a student tries to use one of these strings, then they receive the  forbidden_message , without giving away what the forbidden string is. We recommend using this sparingly, as students will find it confusing. The default  forbidden_message  is \"Invalid Input: This particular answer is forbidden\".  Forbidden strings and student answers are stripped of whitespace before being compared. Thus, if  x + y  is forbidden, then answers containing  x+y  or  x   +   y  will be rejected.", 
            "title": "Forbidden Strings"
        }, 
        {
            "location": "/grading_math/formula_grader/#blacklists-and-whitelists", 
            "text": "You can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example,  sin  is disallowed in correct answers.  grader = FormulaGrader(\n    answers='sqrt(1 - cos(x)^2)',\n    variables=['x'],\n    sample_from={'x': [0, np.pi]},\n    blacklist=['sin']\n)  If you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos.  grader = FormulaGrader(\n    answers='sin(x)/cos(x)',\n    variables=['x'],\n    whitelist=['sin', 'cos']\n)  If you want to exclude all functions, use  whitelist=[None] :  grader = FormulaGrader(\n    answers='pi/2-x',\n    variables=['x'],\n    whitelist=[None] # no functions are allowed\n)  You cannot use a whitelist and a blacklist at the same time.", 
            "title": "Blacklists and Whitelists"
        }, 
        {
            "location": "/grading_math/formula_grader/#required-functions", 
            "text": "You can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    required_functions=['sin', 'cos']\n)", 
            "title": "Required Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#tolerance", 
            "text": "Student inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg,  0.1 ) or a percentage (eg,  \"0.01%\" , which is the default tolerance).  Tolerances must be nonnegative numbers or percentages.  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    tolerance=0.00001\n)  Tolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.", 
            "title": "Tolerance"
        }, 
        {
            "location": "/grading_math/formula_grader/#suffixes", 
            "text": "Numbers with a % at the end will be treated as percentages, and converted to the appropriate decimals.  edX also defines a number of metric suffixes (k, M, G, T, m, u, n, and p) that modify a number appropriately. However, in our experience, these metric suffixes lead to more confusion than use. For example,  2M , which one would expect should be rejected as an error when  2*M  was intended, is accepted by edX, interpreted as  2*10^6 , marked incorrect, and eats a student's attempt. Similarly for all of the other metric suffixes.  We have therefore made the decision to disable metric suffixes by default. If you want to enable them, you can do so using the following.  grader = FormulaGrader(\n    answers='2*m',\n    variables=['m'],\n    metric_suffixes=True\n)  We strongly recommend  not  doing this when using the following variable names: k, M, G, T, m, u, n, and p.", 
            "title": "Suffixes"
        }, 
        {
            "location": "/grading_math/formula_grader/#comparer-functions", 
            "text": "By default, FormulaGrader compares the numerically sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. For example, if grading angles in degrees, it may be useful to compare formulas modulo 360.  To use an alternate comparer, specify the  answers  key as a dictionary with keys  comparer  and  comparer_params  rather than a single string. For example, to compare formulas modulo 360:  def is_coterminal(comparer_params_evals, student_eval, utils):\n    answer = comparer_params_evals[0]\n    reduced = student_eval % (360)\n    return utils.within_tolerance(answer, reduced)\n\ngrader = FormulaGrader(\n    answers={\n        'comparer': is_coterminal,\n        'comparer_params': ['b^2/a'],\n    },\n    variables=['a', 'b'],\n    tolerance='1%'\n)  This grader would accept  'b^2/a'  as well as  'b^2/a + 360' ,  'b^2/a + 720' , etc.  In the grader configuration,  comparer_params  is a list of strings that are numerically evaluated and passed to the comparer function. The  comparer  function is a user-specified function with signature  comparer(comparer_params_evals, student_eval, utils) . When  FormulaGrader  calls the comparer function,  comparer  the argument values are:\n-  comparer_params_evals : The  comparer_params  list, numerically evaluated according to variable and function sampling.\n-  student_eval : The student's input, numerically evaluated according to variable and function sampling\n-  utils : A convenience object that may be helpful when writing custom comparer functions. Has properties:\n  -  utils.tolerance : The tolerance specified in grader configuration,  0.01%  by default\n  -  utils.within_tolerance:  A function with signature  within_tolerance(x, y)  which checks that  y  is within specified tolerance of  x . Can handle scalars, vectors, and matrices. If tolerance was specified as a percentage, then checks that  |x-y|   tolerance * x .", 
            "title": "Comparer Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#other-improvements", 
            "text": "We have made a number of other improvements over the edX formula graders, including:   Square roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like  sqrt(x-1)  or  (x-1)^0.5  always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.  Our parser uses a parsing cache, and hence runs much more efficiently than the edX graders.  If students input an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.  When students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.  Similarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.  If an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the  debug  flag to True, and a more technical message will usually be displayed.  Full sampling details are included when the  debug  flag is set to True.  Enhancements to the AsciiMath renderer (the preview that students see when using  textline  inputs) are available using our  AsciiMath renderer definitions .", 
            "title": "Other Improvements"
        }, 
        {
            "location": "/grading_math/numerical_grader/", 
            "text": "NumericalGrader\n # \n\n\nWhen grading math expressions without functions or variables, you can use NumericalGrader instead of FormulaGrader. NumericalGrader is a specialized version of FormulaGrader whose behavior resembles the edX \nnumericalresponse/\n tag.\n\n\nConfiguration\n # \n\n\nNumericalGrader has all of the same options as FormulaGrader except:\n\n\n\n\ntolerance\n: has a higher default value of \n'5%'\n\n\nfailable_evals\n is always set to 0\n\n\nsamples\n is always set to 1\n\n\nvariables\n is always set to \n[]\n (no variables allowed)\n\n\nsample_from\n is always set to \n{}\n (no variables allowed)\n\n\nuser_functions\n can only define specific functions, with no random functions\n\n\n\n\nIf you are grading simple integers (such as 0, 1, 2, -1, etc), you may want to consider using StringGrader instead of NumericalGrader.", 
            "title": "NumericalGrader"
        }, 
        {
            "location": "/grading_math/numerical_grader/#numericalgrader", 
            "text": "When grading math expressions without functions or variables, you can use NumericalGrader instead of FormulaGrader. NumericalGrader is a specialized version of FormulaGrader whose behavior resembles the edX  numericalresponse/  tag.", 
            "title": "NumericalGrader"
        }, 
        {
            "location": "/grading_math/numerical_grader/#configuration", 
            "text": "NumericalGrader has all of the same options as FormulaGrader except:   tolerance : has a higher default value of  '5%'  failable_evals  is always set to 0  samples  is always set to 1  variables  is always set to  []  (no variables allowed)  sample_from  is always set to  {}  (no variables allowed)  user_functions  can only define specific functions, with no random functions   If you are grading simple integers (such as 0, 1, 2, -1, etc), you may want to consider using StringGrader instead of NumericalGrader.", 
            "title": "Configuration"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/", 
            "text": "MatrixGrader\n # \n\n\nMatrixGrader is an extended version of FormulaGrader used to grade mathematical expressions containing scalars, vectors, and matrices. Authors and students may enter matrix (or vector) expressions by using variables sampled from matrices, or by entering a matrix entry-by-entry.\n\n\nA first example\n # \n\n\nA typical use of MatrixGrader might look like\n\n\n from mitxgraders import *\n\n grader1 = MatrixGrader(\n...   answers='4*A*B^2',\n...   variables=['A', 'B', 'v'],\n...   sample_from={\n...      'A': RealMatrices(), # samples from 2 by 2 matrices by default\n...      'B': RealMatrices(),\n...   }\n... )\n\n\n\n\n\nThe next few lines call the grader as a check function. The inputs \n'4*A*B^2'\n and \n'4*A*B*B'\n are correct:\n\n\n grader1(None, '4*A*B^2')\n{'grade_decimal': 1, 'msg': '', 'ok': True}\n\n grader1(None, '4*A*B*B')\n{'grade_decimal': 1, 'msg': '', 'ok': True}\n\n\n\n\n\nwhile the input \n'4*B^2*A'\n is incorrect because the matrix-sampled variables are non-commutative:\n\n\n grader1(None, '4*B^2*A')\n{'msg': '', 'grade_decimal': 0, 'ok': False}\n\n\n\n\n\nMatrix Sampling\n # \n\n\nIn the MatrixGrader example above, the variables \nA\n and \nB\n were sampled from \nRealMatrices()\n. The \nRealMatrices\n sampling class samples from 2 by 2 matrices by default but can be configured to sample matrices of different shapes. See \nSampling\n for more information about matrix and vector sampling.\n\n\nMatrix Entry\n # \n\n\nIn addition to using variables that vectors and matrices, students can also enter matrices and vectors directly, entry-by-entry.\n\n\n\n\n\n\n\n\nInput with symbols:\n\n\nInput entry-by-entry:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nIn order for matrices entered entry-by-entry to display correctly in edX, authors must use the AsciiMath renderer provided by \ntextline math='true'/\n.\n\n\n\n\n\n\nBy default, students can only input vectors and \nnot matrices\n. This is configured through the \nmax_array_dim\n configuration key:\n\n\n\n\nmax_array_dim=1\n: This (the default) allows students to enter vectors entry-by-entry but not matrices.\n\n\nentering vector \n[x, y + 1, z]\n is OK.\n\n\nentering matrix \n[[1, x], [y, 2]]\n raises an error\n\n\n\n\n\n\nmax_array_dim=2\n: This allows student to vectors and matrices.\n\n\nentering vector \n[x, y + 1, z]\n is OK.\n\n\nentering matrix \n[[1, x], [y, 2]]\n is OK.\n\n\nentering tensor \n[ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ]\n raises an error.\n\n\n\n\n\n\n\n\nThe decision to disable matrix-entry by default is intended to prevent students from entering single-row or single-column matrices when a vector is expected.\n\n\nMatrix Operations and MathArrays\n # \n\n\nMatrixGrader\n uses a custom subclass of \nnumpy.ndarray\n to internally represent matrices. Understanding how the \nMathArray\n class behaves is useful for creating \nMatrixGrader\n problems, and \nMathArray\n can be used directly by problem-authors to add extra constant matrices to a problem.\n\n\nHow MatrixGrader uses MathArrays\n # \n\n\nWhether a matrix is input entry-by-entry or represented through variables, \nMathArray\ns are used to evaluate student expressions.\n\n\nFor example, consider the grader below.\n\n\n grader = MatrixGrader(\n...     answers='2*A*[1, 2, 3] + v',\n...     user_constants={\n...       'A': MathArray([[1, 2, 3], [4, 5, 6]])\n...     },\n...     variables=['v'],\n...     sample_from={\n...       'v': RealVectors(shape=2) # samples a random 2-component vector\n...     }\n... )\n\n\n\n\n\nWhen a student inputs \nv + A*2*[1, 2, 3]\n to the grader above, a calculation similar to\n\n\n v = MathArray([2, -1]) # Really, random samples would be chosen.\n\n A = MathArray([[1, 2, 3], [4, 5, 6]])\n\n v + A*2*MathArray([1, 2, 3])  # below is the result of evaluating student input, which would next be compared to author's answer\nMathArray([30, 63])\n\n\n\n\n\nis performed (but repeated multiple times with different values for the random variables).\n\n\nDimension and Shape\n # \n\n\nMathArray\ns have dimension and shape. For example:\n\n\n\n\n\n\n\n\nStudent Input\n\n\nConverted to\n\n\nName\n\n\ndimension\n\n\nshape\n\n\n\n\n\n\n\n\n\n\n[1, 2, 3]\n\n\nMathArray([1, 2, 3])\n\n\n\"vector\"\n\n\n1\n\n\n(3,  )\n\n\n\n\n\n\n[[1, 2, 3], [4, 5, 6]]\n\n\nMathArray([[1, 2, 3], [4, 5, 6]])\n\n\n\"matrix\"\n\n\n2\n\n\n(2, 3)\n\n\n\n\n\n\n[[1, 2, 3]]\n\n\nMathArray([[1, 2, 3]])\n\n\n\"single-row matrix\"\n\n\n2\n\n\n(1, 3)\n\n\n\n\n\n\n[[1], [2], [3]]\n\n\nMathArray([[1], [2], [3]])\n\n\n\"single-column matrix\"\n\n\n2\n\n\n(3, 1)\n\n\n\n\n\n\n[[[1, 2]], [[3, 4]]]\n\n\nMathArray([[[1, 2]], [[3, 4]]])\n\n\n\"tensor\"\n\n\n3\n\n\n(1, 1, 2)\n\n\n\n\n\n\n\n\nTensor math arrays (dimension 3+) currently have very little support.\n\n\n\n\nWarning\n\n\nNote that a vector, a single-column matrix, and a single-row matrix are distinct entities. We suggest avoiding single-row and single-column matrices.\n\n\nSee \nA note about vectors\n\n\n\n\nAllowed operations\n # \n\n\nMathArray\n support the usual binary operations for vectors and matrices, with appropriate shape restrictions. Compared to \nnumpy.ndarray\n, \nMathArray\n has much more stringent shape restrictions.\n\n\n\n\n\n\nAddition and Subtraction\n: Performed elementwise.\n\n\n\n\n\n\n\n\nExpression\n\n\nraises error unless\n\n\nresult type\n\n\n\n\n\n\n\n\n\n\nMathArray +/- MathArray\n\n\nboth inputs have exactly the same shape\n\n\nMathArray\n\n\n\n\n\n\nMathArray +/- number\n\n\nnumber=0\n\n\nMathArray\n\n\n\n\n\n\nnumber +/- MathArray\n\n\nnumber=0\n\n\nMathArray\n\n\n\n\n\n\n\n\n\n\n\n\nMultiplication\n: Note that \nvector * vector\n is a dot product\n\n\n\n\n\n\n\n\nExpression\n\n\nleft-input shape\n\n\nright-input shape\n\n\nraises error unless\n\n\nresult type\n\n\n\n\n\n\n\n\n\n\nvector * vector\n\n\n(k1, )\n\n\n(k2, )\n\n\nk1=k2\n\n\nnumber\n (dot product of two vectors)\n\n\n\n\n\n\nMathArray * number\n\n\nany\n\n\n-\n\n\n-\n\n\nMathArray\n (elementwise multiplication)\n\n\n\n\n\n\nnumber * MathArray\n\n\n-\n\n\nAny\n\n\n-\n\n\nMathArray\n (elementwise multiplication)\n\n\n\n\n\n\nmatrix * vector\n\n\n(m, n)\n\n\n(k)\n\n\nn=k\n\n\nvector\n with \nn\n components\n\n\n\n\n\n\nvector * matrix\n\n\n(k, )\n\n\n(m, n)\n\n\nm=k\n\n\nvector\n with \nm\n components\n\n\n\n\n\n\nmatrix * matrix\n\n\n(m1, n1)\n\n\n(m2, n2)\n\n\nn1=m2\n\n\nmatrix\n of shape \n(m1, n2)\n\n\n\n\n\n\n\n\n\n\n\n\nDivision\n: Division either raises an error, or is performed elementwise:\n\n\n\n\n\n\n\n\nExpression\n\n\nraises error unless\n\n\nresult type\n\n\n\n\n\n\n\n\n\n\nany / MathArray\n\n\nalways raises error\n\n\n-\n\n\n\n\n\n\nMathArray / number\n\n\n-\n\n\nMathArray\n (elementwise division)\n\n\n\n\n\n\n\n\n\n\n\n\nPowers\n: If \nA\n is a MathArray, then \nA^k\n will always raise an error unless\n\n\n\n\nA\n is a square matrix, \nand\n\n\nk\n is an integer.\n\n\n\n\nIn this case, \nA^k\n is equivalent to:\n\n\n\n\nk\n repeated multiplications of \nA\n if \nk \n 0\n,\n\n\n(inverse of A)^|k|\n if \nk \n 0\n, and\n\n\nthe identity matrix if \nk=0\n.\n\n\n\n\nNote\n: Negative exponents can give students \"too much power\". For example, if you want students to enter the inverse of \n[[1, 2], [3, 4]]\n, you probably want them to enter \n[[-2, 1], [1.5, -0.5]]\n not \n[[1, 2], [3, 4]]^-1\n. To this end, you can disable negative powers in MatrixGrader problems by setting \nnegative_powers=False\n.\n\n\n\n\n\n\nA note about vectors\n # \n\n\nVectors are distinct from single-row matrices and single-column matrices, and can be left- or right-multiplied by a matrix:\n\n\n vec = MathArray([1, 2, 3])\n\n row = MathArray([[1, 2, 3]])\n\n col = MathArray([[1], [2], [3]])\n\n vec + row # raises error\nTraceback (most recent call last):\nMathArrayShapeError: Cannot add/subtract a vector of length 3 with a matrix of shape (rows: 1, cols: 3).\n\n\n A = MathArray([[1, 2, 3], [4, 5, 6]])\n\n A * vec # matrix * vector\nMathArray([14, 32])\n\n other_vec = MathArray([1, 2])\n\n other_vec * A # vector * matrix\nMathArray([ 9, 12, 15])\n\n\n\n\n\nWe suggest avoiding single-column and single-row matrices.\n\n\nShape Errors\n # \n\n\nWhen operations cannot be performed because of shape-mismatch, MathArray raises readable \nStudentFacingError\ns. These error messages are intended to be presented directly to students. For example:\n\n\n A = MathArray([[1, 2], [3, 4], [5, 6]]) # matrix, shape (3, 2)\n\n B = MathArray([[1, 2], [3, 4]])         # matrix, shape (2, 2)\n\n v = MathArray([1, 2])                   # vector, shape (2,  )\n\n\n\n\n\nSome sample error messages:\n\n\n\n\n\n\n\n\nStudent input:\n\n\nValid?\n\n\nStudent receives error message:\n\n\n\n\n\n\n\n\n\n\n'A+B'\n\n\nNo\n\n\nCannot add/subtract a matrix of shape (rows: 3, cols: 2) with a matrix of shape (rows: 2, cols: 2).\n\n\n\n\n\n\n'v*A'\n\n\nNo\n\n\nCannot multiply a vector of length 2 with a matrix of shape (rows: 3, cols: 2).\n\n\n\n\n\n\n'B*v'\n\n\nYes\n\n\nn/a\n\n\n\n\n\n\n'A^2'\n\n\nNo\n\n\nCannot raise a non-square matrix to powers.\n\n\n\n\n\n\n'B^2'\n\n\nYes\n\n\nn/a\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHandling Errors\n # \n\n\nWhile grading a student's input, matrix-related errors can occur in three places:\n\n\n\n\nwhile parsing the student's input,\n\n\nwhile evaluating the student's input, and\n\n\nwhile comparing the student's input to the author's stored answer.\n\n\n\n\nParse errors:\n # \n\n\nFor example, student enters \n'[[1, 2],[3] ]'\n, a matrix missing an entry in second row:\n\n\n grader = MatrixGrader(\n...     answers='[[1, 2], [3, 4]]',\n...     max_array_dim=2, # allow students to enter matrices entry-by-entry\n... )\n\n student_input = '[[1, 2], [3]]'\n\n try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     str(error.message) # students see this error message\n\nUnable to parse vector/matrix. If you're trying to enter a matrix, this is most likely caused by an unequal number of elements in each row.\n\n\n\n\n\n\nSuch parse errors are \nalways raised\n to students.\n\n\nShape-mismatch errors during evaluation\n # \n\n\nIf a student submits an answer that will raise shape-mismatch errors then an error is raised with a helpful message. This avoids consuming one of the student's attempts. For example:\n\n\n grader = MatrixGrader(\n...     answers='[11, 22, 33]',\n... )\n\n student_input = '[10, 20, 30] + [1, 2]' # Error! Adding vectors with different shapes\n\n try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     str(error.message) # students see this error message\n'Cannot add/subtract a vector of length 3 with a vector of length 2.'\n\n\n\n\n\nIf you would rather mark the student incorrect when shape errors occur (and also consume an attempt), set \nshape_errors=False\n.\n\n\nShape-mismatch errors during comparison\n # \n\n\nIf the author's answer is a 3-component vector, and the student submits a different 3-component vector, then they will be marked incorrect. However, if the student submits a 2-component vector or a number, they will receive an error message:\n\n\n grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n... )\n\n student_input = '[1, 2, -3]' # wrong answer\n\n grader(None, student_input) # grade the input like edX would\n{'msg': '', 'grade_decimal': 0, 'ok': False}\n\n\n student_input = '[1, 2, 3, 4]' # too many components\n\n try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     str(error.message) # students see this error message\n'Expected answer to be a vector, but input is a vector of incorrect shape'\n\n\n student_input = '0' # scalar; should be a vector\n\n try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     str(error.message) # students see this error message\n'Expected answer to be a vector, but input is a scalar'\n\n\n\n\n\nThe default handing shape errors that arise when comparing student input to author's answer is:\n  - raise an error (do not mark student incorrect), and\n  - reveal the desired type (above, a vector) but not the desired shape (above, 3-components)\n\n\nThis behavior can be configured through the \nanswer_shape_mismatch\n key. For example, to:\n  - mark students wrong instead of raising an error, and\n  - reveal the shape and the type\nwe can use:\n\n\n grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n...     answer_shape_mismatch={\n...         'is_raised': False,\n...         'msg_detail': 'shape' # must be one of: None, 'type', 'shape'\n...     }\n... )\n\n student_input = '0' # wrong shape\n\n grader(None, student_input) # grade the input like edX would\n{'grade_decimal': 0, 'msg': 'Expected answer to be a vector of length 3, but input is a scalar', 'ok': False}\n\n\n\n\n\nMatrix Functions\n # \n\n\nMatrixGrader provides all the default functions of \nFormulaGrader\n (\nsin\n, \ncos\n, etc.) plus some extras such as \ntrans(A)\n (transpose) and \ndet(A)\n (determinant). See \nFunction Listing\n for full list\n\n\nConfiguration Options\n #", 
            "title": "MatrixGrader"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrixgrader", 
            "text": "MatrixGrader is an extended version of FormulaGrader used to grade mathematical expressions containing scalars, vectors, and matrices. Authors and students may enter matrix (or vector) expressions by using variables sampled from matrices, or by entering a matrix entry-by-entry.", 
            "title": "MatrixGrader"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#a-first-example", 
            "text": "A typical use of MatrixGrader might look like   from mitxgraders import *  grader1 = MatrixGrader(\n...   answers='4*A*B^2',\n...   variables=['A', 'B', 'v'],\n...   sample_from={\n...      'A': RealMatrices(), # samples from 2 by 2 matrices by default\n...      'B': RealMatrices(),\n...   }\n... )  The next few lines call the grader as a check function. The inputs  '4*A*B^2'  and  '4*A*B*B'  are correct:   grader1(None, '4*A*B^2')\n{'grade_decimal': 1, 'msg': '', 'ok': True}  grader1(None, '4*A*B*B')\n{'grade_decimal': 1, 'msg': '', 'ok': True}  while the input  '4*B^2*A'  is incorrect because the matrix-sampled variables are non-commutative:   grader1(None, '4*B^2*A')\n{'msg': '', 'grade_decimal': 0, 'ok': False}", 
            "title": "A first example"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrix-sampling", 
            "text": "In the MatrixGrader example above, the variables  A  and  B  were sampled from  RealMatrices() . The  RealMatrices  sampling class samples from 2 by 2 matrices by default but can be configured to sample matrices of different shapes. See  Sampling  for more information about matrix and vector sampling.", 
            "title": "Matrix Sampling"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrix-entry", 
            "text": "In addition to using variables that vectors and matrices, students can also enter matrices and vectors directly, entry-by-entry.     Input with symbols:  Input entry-by-entry:            Note   In order for matrices entered entry-by-entry to display correctly in edX, authors must use the AsciiMath renderer provided by  textline math='true'/ .    By default, students can only input vectors and  not matrices . This is configured through the  max_array_dim  configuration key:   max_array_dim=1 : This (the default) allows students to enter vectors entry-by-entry but not matrices.  entering vector  [x, y + 1, z]  is OK.  entering matrix  [[1, x], [y, 2]]  raises an error    max_array_dim=2 : This allows student to vectors and matrices.  entering vector  [x, y + 1, z]  is OK.  entering matrix  [[1, x], [y, 2]]  is OK.  entering tensor  [ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ]  raises an error.     The decision to disable matrix-entry by default is intended to prevent students from entering single-row or single-column matrices when a vector is expected.", 
            "title": "Matrix Entry"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrix-operations-and-matharrays", 
            "text": "MatrixGrader  uses a custom subclass of  numpy.ndarray  to internally represent matrices. Understanding how the  MathArray  class behaves is useful for creating  MatrixGrader  problems, and  MathArray  can be used directly by problem-authors to add extra constant matrices to a problem.", 
            "title": "Matrix Operations and MathArrays"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#how-matrixgrader-uses-matharrays", 
            "text": "Whether a matrix is input entry-by-entry or represented through variables,  MathArray s are used to evaluate student expressions.  For example, consider the grader below.   grader = MatrixGrader(\n...     answers='2*A*[1, 2, 3] + v',\n...     user_constants={\n...       'A': MathArray([[1, 2, 3], [4, 5, 6]])\n...     },\n...     variables=['v'],\n...     sample_from={\n...       'v': RealVectors(shape=2) # samples a random 2-component vector\n...     }\n... )  When a student inputs  v + A*2*[1, 2, 3]  to the grader above, a calculation similar to   v = MathArray([2, -1]) # Really, random samples would be chosen.  A = MathArray([[1, 2, 3], [4, 5, 6]])  v + A*2*MathArray([1, 2, 3])  # below is the result of evaluating student input, which would next be compared to author's answer\nMathArray([30, 63])  is performed (but repeated multiple times with different values for the random variables).", 
            "title": "How MatrixGrader uses MathArrays"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#dimension-and-shape", 
            "text": "MathArray s have dimension and shape. For example:     Student Input  Converted to  Name  dimension  shape      [1, 2, 3]  MathArray([1, 2, 3])  \"vector\"  1  (3,  )    [[1, 2, 3], [4, 5, 6]]  MathArray([[1, 2, 3], [4, 5, 6]])  \"matrix\"  2  (2, 3)    [[1, 2, 3]]  MathArray([[1, 2, 3]])  \"single-row matrix\"  2  (1, 3)    [[1], [2], [3]]  MathArray([[1], [2], [3]])  \"single-column matrix\"  2  (3, 1)    [[[1, 2]], [[3, 4]]]  MathArray([[[1, 2]], [[3, 4]]])  \"tensor\"  3  (1, 1, 2)     Tensor math arrays (dimension 3+) currently have very little support.   Warning  Note that a vector, a single-column matrix, and a single-row matrix are distinct entities. We suggest avoiding single-row and single-column matrices.  See  A note about vectors", 
            "title": "Dimension and Shape"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#allowed-operations", 
            "text": "MathArray  support the usual binary operations for vectors and matrices, with appropriate shape restrictions. Compared to  numpy.ndarray ,  MathArray  has much more stringent shape restrictions.    Addition and Subtraction : Performed elementwise.     Expression  raises error unless  result type      MathArray +/- MathArray  both inputs have exactly the same shape  MathArray    MathArray +/- number  number=0  MathArray    number +/- MathArray  number=0  MathArray       Multiplication : Note that  vector * vector  is a dot product     Expression  left-input shape  right-input shape  raises error unless  result type      vector * vector  (k1, )  (k2, )  k1=k2  number  (dot product of two vectors)    MathArray * number  any  -  -  MathArray  (elementwise multiplication)    number * MathArray  -  Any  -  MathArray  (elementwise multiplication)    matrix * vector  (m, n)  (k)  n=k  vector  with  n  components    vector * matrix  (k, )  (m, n)  m=k  vector  with  m  components    matrix * matrix  (m1, n1)  (m2, n2)  n1=m2  matrix  of shape  (m1, n2)       Division : Division either raises an error, or is performed elementwise:     Expression  raises error unless  result type      any / MathArray  always raises error  -    MathArray / number  -  MathArray  (elementwise division)       Powers : If  A  is a MathArray, then  A^k  will always raise an error unless   A  is a square matrix,  and  k  is an integer.   In this case,  A^k  is equivalent to:   k  repeated multiplications of  A  if  k   0 ,  (inverse of A)^|k|  if  k   0 , and  the identity matrix if  k=0 .   Note : Negative exponents can give students \"too much power\". For example, if you want students to enter the inverse of  [[1, 2], [3, 4]] , you probably want them to enter  [[-2, 1], [1.5, -0.5]]  not  [[1, 2], [3, 4]]^-1 . To this end, you can disable negative powers in MatrixGrader problems by setting  negative_powers=False .", 
            "title": "Allowed operations"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#a-note-about-vectors", 
            "text": "Vectors are distinct from single-row matrices and single-column matrices, and can be left- or right-multiplied by a matrix:   vec = MathArray([1, 2, 3])  row = MathArray([[1, 2, 3]])  col = MathArray([[1], [2], [3]])  vec + row # raises error\nTraceback (most recent call last):\nMathArrayShapeError: Cannot add/subtract a vector of length 3 with a matrix of shape (rows: 1, cols: 3).  A = MathArray([[1, 2, 3], [4, 5, 6]])  A * vec # matrix * vector\nMathArray([14, 32])  other_vec = MathArray([1, 2])  other_vec * A # vector * matrix\nMathArray([ 9, 12, 15])  We suggest avoiding single-column and single-row matrices.", 
            "title": "A note about vectors"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#shape-errors", 
            "text": "When operations cannot be performed because of shape-mismatch, MathArray raises readable  StudentFacingError s. These error messages are intended to be presented directly to students. For example:   A = MathArray([[1, 2], [3, 4], [5, 6]]) # matrix, shape (3, 2)  B = MathArray([[1, 2], [3, 4]])         # matrix, shape (2, 2)  v = MathArray([1, 2])                   # vector, shape (2,  )  Some sample error messages:     Student input:  Valid?  Student receives error message:      'A+B'  No  Cannot add/subtract a matrix of shape (rows: 3, cols: 2) with a matrix of shape (rows: 2, cols: 2).    'v*A'  No  Cannot multiply a vector of length 2 with a matrix of shape (rows: 3, cols: 2).    'B*v'  Yes  n/a    'A^2'  No  Cannot raise a non-square matrix to powers.    'B^2'  Yes  n/a", 
            "title": "Shape Errors"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#handling-errors", 
            "text": "While grading a student's input, matrix-related errors can occur in three places:   while parsing the student's input,  while evaluating the student's input, and  while comparing the student's input to the author's stored answer.", 
            "title": "Handling Errors"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#parse-errors", 
            "text": "For example, student enters  '[[1, 2],[3] ]' , a matrix missing an entry in second row:   grader = MatrixGrader(\n...     answers='[[1, 2], [3, 4]]',\n...     max_array_dim=2, # allow students to enter matrices entry-by-entry\n... )  student_input = '[[1, 2], [3]]'  try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     str(error.message) # students see this error message Unable to parse vector/matrix. If you're trying to enter a matrix, this is most likely caused by an unequal number of elements in each row.   Such parse errors are  always raised  to students.", 
            "title": "Parse errors:"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#shape-mismatch-errors-during-evaluation", 
            "text": "If a student submits an answer that will raise shape-mismatch errors then an error is raised with a helpful message. This avoids consuming one of the student's attempts. For example:   grader = MatrixGrader(\n...     answers='[11, 22, 33]',\n... )  student_input = '[10, 20, 30] + [1, 2]' # Error! Adding vectors with different shapes  try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     str(error.message) # students see this error message\n'Cannot add/subtract a vector of length 3 with a vector of length 2.'  If you would rather mark the student incorrect when shape errors occur (and also consume an attempt), set  shape_errors=False .", 
            "title": "Shape-mismatch errors during evaluation"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#shape-mismatch-errors-during-comparison", 
            "text": "If the author's answer is a 3-component vector, and the student submits a different 3-component vector, then they will be marked incorrect. However, if the student submits a 2-component vector or a number, they will receive an error message:   grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n... )  student_input = '[1, 2, -3]' # wrong answer  grader(None, student_input) # grade the input like edX would\n{'msg': '', 'grade_decimal': 0, 'ok': False}  student_input = '[1, 2, 3, 4]' # too many components  try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     str(error.message) # students see this error message\n'Expected answer to be a vector, but input is a vector of incorrect shape'  student_input = '0' # scalar; should be a vector  try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     str(error.message) # students see this error message\n'Expected answer to be a vector, but input is a scalar'  The default handing shape errors that arise when comparing student input to author's answer is:\n  - raise an error (do not mark student incorrect), and\n  - reveal the desired type (above, a vector) but not the desired shape (above, 3-components)  This behavior can be configured through the  answer_shape_mismatch  key. For example, to:\n  - mark students wrong instead of raising an error, and\n  - reveal the shape and the type\nwe can use:   grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n...     answer_shape_mismatch={\n...         'is_raised': False,\n...         'msg_detail': 'shape' # must be one of: None, 'type', 'shape'\n...     }\n... )  student_input = '0' # wrong shape  grader(None, student_input) # grade the input like edX would\n{'grade_decimal': 0, 'msg': 'Expected answer to be a vector of length 3, but input is a scalar', 'ok': False}", 
            "title": "Shape-mismatch errors during comparison"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrix-functions", 
            "text": "MatrixGrader provides all the default functions of  FormulaGrader  ( sin ,  cos , etc.) plus some extras such as  trans(A)  (transpose) and  det(A)  (determinant). See  Function Listing  for full list", 
            "title": "Matrix Functions"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#configuration-options", 
            "text": "", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/grading_math/sampling/", 
            "text": "Sampling\n # \n\n\nWhenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called \nsampling sets\n. We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins.\n\n\nThese sampling classes are available for use in FormulaGrader.\n\n\nVariable Names\n # \n\n\nVariable names must start with a letter, and can continue with letters, numbers, and underscores. Variable names may conclude with an arbitrary number of apostrophes. The same naming conventions apply to user-defined constants.\n\n\nIt is also possible to have tensor variable names. The following three forms are available:\n\n\n\n\nT^{ijk}\n\n\nT_{ijk}\n\n\nT_{ijk}^{123}\n (note that lowered indices must come first)\n\n\n\n\nThe tensor name itself must start with a letter, and may continue with letters and numbers. The indices may be any combination of letters and numbers. After the indices, you may have apostrophes, such as T^{ijk}'' (tensors can be differentiated too!).\n\n\nVariable Sampling: Numbers\n # \n\n\nThese sampling sets generate a random number on demand. It may be real or complex.\n\n\nRealInterval\n # \n\n\nSample from a real interval defined by a \nstart\n and a \nstop\n value. RealInterval can be initialized using explicit values, or an interval.\n\n\n from mitxgraders import *\n\n # Generate random real numbers between 3 and 7\n\n sampler = RealInterval(start=3, stop=7)\n\n # This is equivalent to\n\n sampler = RealInterval([3, 7])\n\n # The default is [1, 5]\n\n sampler = RealInterval()\n\n\n\n\n\nIntegerRange\n # \n\n\nSample from an integer defined by a \nstart\n and a \nstop\n value (both start and stop are included in the range). IntegerRange can be initialized using explicit values, or an interval.\n\n\n # Generate random integers between 3 and 7 inclusive\n\n sampler = IntegerRange(start=3, stop=7)\n\n # This is equivalent to\n\n sampler = IntegerRange([3, 7])\n\n # The default is [1, 5]\n\n sampler = IntegerRange()\n\n\n\n\n\nComplexRectangle\n # \n\n\nSample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range.\n\n\n # Select random complex numbers from 0 to 1 + i\n\n sampler = ComplexRectangle(re=[0, 1], im=[0, 1])\n\n # The default is re=[1, 3], im=[1, 3]\n\n sampler = ComplexRectangle()\n\n\n\n\n\nComplexSector\n # \n\n\nSample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range.\n\n\n import numpy as np\n\n # Select random complex numbers from inside the unit circle\n\n sampler = ComplexSector(modulus=[0, 1], argument=[-np.pi, np.pi])\n\n # The default is modulus=[1, 3], argument=[0, pi/2]\n\n sampler = ComplexSector()\n\n\n\n\n\nVariable Sampling: Vectors and Matrices\n # \n\n\nRealVectors\n # \n\n\nSample real vectors with specified shape (number of components) and norm.\n\n\n # sample real vectors with 4 components and norm between 5 and 10\n\n sampler = RealVectors(shape=4, norm=[5, 10])\n\n # For consistency with RealMatrices, shape can be specified as list:\n\n sampler = RealVectors(shape=[4], norm=[5, 10])\n\n # The default is 3 component vectors with norm from 1 to 5\n\n sampler = RealVectors()\n\n\n\n\n\nRealMatrices\n # \n\n\nSample real matrices of a specific shape and norm. (\nRealMatrices\n uses the Frobenius norm.)\n\n\n # Sample 3 b 2 real matrices with norm between 5 and 10\n\n sampler = RealMatrices(shape=[3, 2], norm=[5, 10])\n\n # the default is shape=[2, 2] and norm=[1, 5]\n\n RealMatrices()\n\n\n\n\n\nVariable Sampling: Generic\n # \n\n\nDiscreteSet\n # \n\n\nSample from a discrete set of values, specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set.\n\n\n # Select random numbers from (1, 3, 5, 7, 9)\n\n sampler = DiscreteSet((1, 3, 5, 7, 9))\n\n # Always select 3.5\n\n sampler = DiscreteSet(3.5)\n\n\n\n\n\nDependentSampler\n # \n\n\nCompute a value for a variable based on the values of other variables. The sampler must be initialized with a list of variables that it depends on, as well as the formula used to perform the computation. The formula can use any base functions, but no user-defined functions. DependentSamplers can depend on other dependent variables. If you construct a self-referential chain, an error will occur.\n\n\n # Set radius based on the random values of x, y and z\n\n sampler = DependentSampler(depends=[\nx\n, \ny\n, \nz\n], formula=\nsqrt(x^2+y^2+z^2)\n)\n\n\n\n\n\nFunction Sampling\n # \n\n\nWhen a random function can be specified, we need a sampling set that returns a random function on demand.\n\n\nSpecificFunctions\n # \n\n\nSamples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set.\n\n\n # Select either sin or cos randomly\n\n functionsampler = SpecificFunctions([np.cos, np.sin])\n\n # Always select a single lambda function\n\n functionsampler = SpecificFunctions(lambda x: x*x)\n\n\n\n\n\nRandomFunction\n # \n\n\nGenerate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude.\n\n\n # Generate a random function\n\n functionsampler = RandomFunction(center=1, amplitude=2)\n\n # The default is center=0, amplitude=10\n\n functionsampler = RandomFunction()\n\n\n\n\n\nYou can control how many random sinusoids are added together by specifying \nnum_terms\n.\n\n\n # Generate a random sinusoid\n\n functionsampler = RandomFunction(num_terms=1)\n\n\n\n\n\nYou can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension.\n\n\n # Generate a function that takes in two values and outputs a 3D vector\n\n functionsampler = RandomFunction(input_dim=2, output_dim=3)", 
            "title": "Sampling Sets"
        }, 
        {
            "location": "/grading_math/sampling/#sampling", 
            "text": "Whenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called  sampling sets . We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins.  These sampling classes are available for use in FormulaGrader.", 
            "title": "Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#variable-names", 
            "text": "Variable names must start with a letter, and can continue with letters, numbers, and underscores. Variable names may conclude with an arbitrary number of apostrophes. The same naming conventions apply to user-defined constants.  It is also possible to have tensor variable names. The following three forms are available:   T^{ijk}  T_{ijk}  T_{ijk}^{123}  (note that lowered indices must come first)   The tensor name itself must start with a letter, and may continue with letters and numbers. The indices may be any combination of letters and numbers. After the indices, you may have apostrophes, such as T^{ijk}'' (tensors can be differentiated too!).", 
            "title": "Variable Names"
        }, 
        {
            "location": "/grading_math/sampling/#variable-sampling-numbers", 
            "text": "These sampling sets generate a random number on demand. It may be real or complex.", 
            "title": "Variable Sampling: Numbers"
        }, 
        {
            "location": "/grading_math/sampling/#realinterval", 
            "text": "Sample from a real interval defined by a  start  and a  stop  value. RealInterval can be initialized using explicit values, or an interval.   from mitxgraders import *  # Generate random real numbers between 3 and 7  sampler = RealInterval(start=3, stop=7)  # This is equivalent to  sampler = RealInterval([3, 7])  # The default is [1, 5]  sampler = RealInterval()", 
            "title": "RealInterval"
        }, 
        {
            "location": "/grading_math/sampling/#integerrange", 
            "text": "Sample from an integer defined by a  start  and a  stop  value (both start and stop are included in the range). IntegerRange can be initialized using explicit values, or an interval.   # Generate random integers between 3 and 7 inclusive  sampler = IntegerRange(start=3, stop=7)  # This is equivalent to  sampler = IntegerRange([3, 7])  # The default is [1, 5]  sampler = IntegerRange()", 
            "title": "IntegerRange"
        }, 
        {
            "location": "/grading_math/sampling/#complexrectangle", 
            "text": "Sample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range.   # Select random complex numbers from 0 to 1 + i  sampler = ComplexRectangle(re=[0, 1], im=[0, 1])  # The default is re=[1, 3], im=[1, 3]  sampler = ComplexRectangle()", 
            "title": "ComplexRectangle"
        }, 
        {
            "location": "/grading_math/sampling/#complexsector", 
            "text": "Sample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range.   import numpy as np  # Select random complex numbers from inside the unit circle  sampler = ComplexSector(modulus=[0, 1], argument=[-np.pi, np.pi])  # The default is modulus=[1, 3], argument=[0, pi/2]  sampler = ComplexSector()", 
            "title": "ComplexSector"
        }, 
        {
            "location": "/grading_math/sampling/#variable-sampling-vectors-and-matrices", 
            "text": "", 
            "title": "Variable Sampling: Vectors and Matrices"
        }, 
        {
            "location": "/grading_math/sampling/#realvectors", 
            "text": "Sample real vectors with specified shape (number of components) and norm.   # sample real vectors with 4 components and norm between 5 and 10  sampler = RealVectors(shape=4, norm=[5, 10])  # For consistency with RealMatrices, shape can be specified as list:  sampler = RealVectors(shape=[4], norm=[5, 10])  # The default is 3 component vectors with norm from 1 to 5  sampler = RealVectors()", 
            "title": "RealVectors"
        }, 
        {
            "location": "/grading_math/sampling/#realmatrices", 
            "text": "Sample real matrices of a specific shape and norm. ( RealMatrices  uses the Frobenius norm.)   # Sample 3 b 2 real matrices with norm between 5 and 10  sampler = RealMatrices(shape=[3, 2], norm=[5, 10])  # the default is shape=[2, 2] and norm=[1, 5]  RealMatrices()", 
            "title": "RealMatrices"
        }, 
        {
            "location": "/grading_math/sampling/#variable-sampling-generic", 
            "text": "", 
            "title": "Variable Sampling: Generic"
        }, 
        {
            "location": "/grading_math/sampling/#discreteset", 
            "text": "Sample from a discrete set of values, specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set.   # Select random numbers from (1, 3, 5, 7, 9)  sampler = DiscreteSet((1, 3, 5, 7, 9))  # Always select 3.5  sampler = DiscreteSet(3.5)", 
            "title": "DiscreteSet"
        }, 
        {
            "location": "/grading_math/sampling/#dependentsampler", 
            "text": "Compute a value for a variable based on the values of other variables. The sampler must be initialized with a list of variables that it depends on, as well as the formula used to perform the computation. The formula can use any base functions, but no user-defined functions. DependentSamplers can depend on other dependent variables. If you construct a self-referential chain, an error will occur.   # Set radius based on the random values of x, y and z  sampler = DependentSampler(depends=[ x ,  y ,  z ], formula= sqrt(x^2+y^2+z^2) )", 
            "title": "DependentSampler"
        }, 
        {
            "location": "/grading_math/sampling/#function-sampling", 
            "text": "When a random function can be specified, we need a sampling set that returns a random function on demand.", 
            "title": "Function Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#specificfunctions", 
            "text": "Samples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set.   # Select either sin or cos randomly  functionsampler = SpecificFunctions([np.cos, np.sin])  # Always select a single lambda function  functionsampler = SpecificFunctions(lambda x: x*x)", 
            "title": "SpecificFunctions"
        }, 
        {
            "location": "/grading_math/sampling/#randomfunction", 
            "text": "Generate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude.   # Generate a random function  functionsampler = RandomFunction(center=1, amplitude=2)  # The default is center=0, amplitude=10  functionsampler = RandomFunction()  You can control how many random sinusoids are added together by specifying  num_terms .   # Generate a random sinusoid  functionsampler = RandomFunction(num_terms=1)  You can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension.   # Generate a function that takes in two values and outputs a 3D vector  functionsampler = RandomFunction(input_dim=2, output_dim=3)", 
            "title": "RandomFunction"
        }, 
        {
            "location": "/grading_math/function_list/", 
            "text": "Function Listing\n # \n\n\n\n\nNote\n\n\nBelow, expressions marked with a * may require our \nAsciiMath renderer definitions\n to display properly in edX.\n\n\n\n\nFormulaGrader Functions\n # \n\n\nBy default, all of the following functions are made available to students in \nFormulaGrader\n problems.\n\n\n\n\nsin(x)\n Sine\n\n\ncos(x)\n Cosine\n\n\ntan(x)\n Tangent\n\n\nsec(x)\n Secant\n\n\ncsc(x)\n Cosecant\n\n\ncot(x)\n Cotangent\n\n\nsqrt(x)\n Square Root\n\n\nlog10(x)\n Log (base 10)*\n\n\nlog2(x)\n Log (base 2)*\n\n\nln(x)\n Natural logarithm\n\n\nexp(x)\n Exponential\n\n\narccos(x)\n Inverse Cosine\n\n\narcsin(x)\n Inverse Sine\n\n\narctan(x)\n Inverse Tangent\n\n\narcsec(x)\n Inverse Secant*\n\n\narccsc(x)\n Inverse Cosecant*\n\n\narccot(x)\n Inverse Cotangent*\n\n\nabs(x)\n Absolute value (real) or modulus (complex)\n\n\nfactorial(x)\n and \nfact(x)\n Factorial*\n\n\ndomain: all complex numbers except negative integers. Large outputs may raise \nOverflowError\ns.\n\n\n\n\n\n\nsinh(x)\n Hyperbolic Sine\n\n\ncosh(x)\n Hyperbolic Cosine\n\n\ntanh(x)\n Hyperbolic Tangent\n\n\nsech(x)\n Hyperbolic Secant\n\n\ncsch(x)\n Hyperbolic Cosecant\n\n\ncoth(x)\n Hyperbolic Cotangent\n\n\narcsinh(x)\n Inverse Hyperbolic Sine*\n\n\narccosh(x)\n Inverse Hyperbolic Cosine*\n\n\narctanh(x)\n Inverse Hyperbolic Tangent*\n\n\narcsech(x)\n Inverse Hyperbolic Secant*\n\n\narccsch(x)\n Inverse Hyperbolic Cosecant*\n\n\narccoth(x)\n Inverse Hyperbolic Cotangent*\n\n\nre(x)\n Real part of a complex expression*\n\n\nim(x)\n Imaginary part of a complex expression*\n\n\nconj(x)\n Complex conjugate of a complex expression*\n\n\n\n\nMatrixGrader Functions\n # \n\n\nIn \nMatrixGrader\n problems, all \nFormulaGrader\n functions are available by default, as are the following extra functions:\n\n\n\n\nabs(x)\n: absolute value; input can be number or vector\n\n\nadj(x)\n: conjugate transpose, same as \nctrans(x)\n\n\ncross(x, y)\n: cross product, inputs must be 3-component vectors\n\n\nctrans(x)\n: conjugate transpose, same as \nadj(x)\n\n\ndet(x)\n: determinant, input must be square matrix\n\n\nnorm(x)\n: Frobenius norm, works for scalars, vectors, and matrices\n\n\ntr(x)\n: transpose, input must be square matrix\n\n\ntrace(x)\n: trace", 
            "title": "Function List"
        }, 
        {
            "location": "/grading_math/function_list/#function-listing", 
            "text": "Note  Below, expressions marked with a * may require our  AsciiMath renderer definitions  to display properly in edX.", 
            "title": "Function Listing"
        }, 
        {
            "location": "/grading_math/function_list/#formulagrader-functions", 
            "text": "By default, all of the following functions are made available to students in  FormulaGrader  problems.   sin(x)  Sine  cos(x)  Cosine  tan(x)  Tangent  sec(x)  Secant  csc(x)  Cosecant  cot(x)  Cotangent  sqrt(x)  Square Root  log10(x)  Log (base 10)*  log2(x)  Log (base 2)*  ln(x)  Natural logarithm  exp(x)  Exponential  arccos(x)  Inverse Cosine  arcsin(x)  Inverse Sine  arctan(x)  Inverse Tangent  arcsec(x)  Inverse Secant*  arccsc(x)  Inverse Cosecant*  arccot(x)  Inverse Cotangent*  abs(x)  Absolute value (real) or modulus (complex)  factorial(x)  and  fact(x)  Factorial*  domain: all complex numbers except negative integers. Large outputs may raise  OverflowError s.    sinh(x)  Hyperbolic Sine  cosh(x)  Hyperbolic Cosine  tanh(x)  Hyperbolic Tangent  sech(x)  Hyperbolic Secant  csch(x)  Hyperbolic Cosecant  coth(x)  Hyperbolic Cotangent  arcsinh(x)  Inverse Hyperbolic Sine*  arccosh(x)  Inverse Hyperbolic Cosine*  arctanh(x)  Inverse Hyperbolic Tangent*  arcsech(x)  Inverse Hyperbolic Secant*  arccsch(x)  Inverse Hyperbolic Cosecant*  arccoth(x)  Inverse Hyperbolic Cotangent*  re(x)  Real part of a complex expression*  im(x)  Imaginary part of a complex expression*  conj(x)  Complex conjugate of a complex expression*", 
            "title": "FormulaGrader Functions"
        }, 
        {
            "location": "/grading_math/function_list/#matrixgrader-functions", 
            "text": "In  MatrixGrader  problems, all  FormulaGrader  functions are available by default, as are the following extra functions:   abs(x) : absolute value; input can be number or vector  adj(x) : conjugate transpose, same as  ctrans(x)  cross(x, y) : cross product, inputs must be 3-component vectors  ctrans(x) : conjugate transpose, same as  adj(x)  det(x) : determinant, input must be square matrix  norm(x) : Frobenius norm, works for scalars, vectors, and matrices  tr(x) : transpose, input must be square matrix  trace(x) : trace", 
            "title": "MatrixGrader Functions"
        }, 
        {
            "location": "/grading_math/renderer/", 
            "text": "AsciiMath Renderer Definitions\n # \n\n\nWhen math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview:\n\n\nformulaequationinput/\n\nor\n\ntextline math=\n1\n/\n\n\n\n\n\nThe \nformulaequationinput\n tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from \nformulaequationinput\n is better than that of \ntextline\n, as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to \nformulaequationinput\n are that it doesn't recognize vectors such as \nvecx\n or \nhatx\n, the factorial and conjugation functions just apply as \nfact(x)\n and \nconj(x)\n, and because the processing is done server-side, we are unable to enhance the display at all.\n\n\nThe \ntextline\n tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in \n1/arctanh(x)\n in textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews.\n\n\nThis article describes how to use our new AsciiMath renderer definitions with a \ntextline\n tag.\n\n\nHow it works\n # \n\n\nThe renderer definitions are located in a javascript file, \nMJxPrep.js\n, which should be uploaded to the static assets folder for your course. This javascript file loads two components: symbol definitions and a preprocessor.\n\n\nThe symbol definitions are used to teach AsciiMath how to display various functions properly, such as \nre\n, \nim\n, \narctanh\n etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem.\n\n\nscript type=\ntext/javascript\n src=\n/static/MJxPrep.js\n/script\n\n\n\n\n\nSome functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions are \nlog10\n, \nlog2\n, \nfact\n and \nfactorial\n. To use these, you need to add \npreprocessorClassName\n and \npreprocessorSrc\n properties to any textline tags that use the preprocessor.\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline correct_answer=\n1/fact(5)\n math=\n1\n preprocessorClassName=\nMJxPrep\n preprocessorSrc=\n/static/MJxPrep.js\n/\n\n\n/customresponse\n\n\n\n\n\nIf you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately).\n\n\nNotes\n # \n\n\n\n\n\n\nNote that you don't need to use the grading library to take advantage of the symbol definitions and/or the preprocessor; they work just as well for the normal edX \nformularesponse\n problems!\n\n\n\n\n\n\nThe javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many \ntextline\n boxes as you like.\n\n\n\n\n\n\nIf you have a display issue with AsciiMath, it's likely that you can extend the symbol definitions and preprocessor to make your expressions display nicely for students.\n\n\n\n\n\n\nThe \nfunction listing\n article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.", 
            "title": "AsciiMath Renderer Definitions"
        }, 
        {
            "location": "/grading_math/renderer/#asciimath-renderer-definitions", 
            "text": "When math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview:  formulaequationinput/ \nor textline math= 1 /   The  formulaequationinput  tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from  formulaequationinput  is better than that of  textline , as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to  formulaequationinput  are that it doesn't recognize vectors such as  vecx  or  hatx , the factorial and conjugation functions just apply as  fact(x)  and  conj(x) , and because the processing is done server-side, we are unable to enhance the display at all.  The  textline  tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in  1/arctanh(x)  in textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews.  This article describes how to use our new AsciiMath renderer definitions with a  textline  tag.", 
            "title": "AsciiMath Renderer Definitions"
        }, 
        {
            "location": "/grading_math/renderer/#how-it-works", 
            "text": "The renderer definitions are located in a javascript file,  MJxPrep.js , which should be uploaded to the static assets folder for your course. This javascript file loads two components: symbol definitions and a preprocessor.  The symbol definitions are used to teach AsciiMath how to display various functions properly, such as  re ,  im ,  arctanh  etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem.  script type= text/javascript  src= /static/MJxPrep.js /script   Some functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions are  log10 ,  log2 ,  fact  and  factorial . To use these, you need to add  preprocessorClassName  and  preprocessorSrc  properties to any textline tags that use the preprocessor.  customresponse cfn= grader \n     textline correct_answer= 1/fact(5)  math= 1  preprocessorClassName= MJxPrep  preprocessorSrc= /static/MJxPrep.js /  /customresponse   If you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately).", 
            "title": "How it works"
        }, 
        {
            "location": "/grading_math/renderer/#notes", 
            "text": "Note that you don't need to use the grading library to take advantage of the symbol definitions and/or the preprocessor; they work just as well for the normal edX  formularesponse  problems!    The javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many  textline  boxes as you like.    If you have a display issue with AsciiMath, it's likely that you can extend the symbol definitions and preprocessor to make your expressions display nicely for students.    The  function listing  article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.", 
            "title": "Notes"
        }, 
        {
            "location": "/grading_lists/list_grader/", 
            "text": "ListGrader\n # \n\n\nA \nListGrader\n is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast, \nSingleListGrader\n can be used to grade a list of items entered all at once into a single answer box.) ListGraders work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student.\n\n\nBasic usage\n # \n\n\nIn this example, each input is checked against the corresponding answer, using \nStringGrader\n as the subgrader.\n\n\ngrader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader()\n)\n\n\n\n\nEach element of answers is set as an answer that is passed as the answers key into the subgrader. This should be set up as two input boxes that the student types in.\n\n\nIn the above example, the item grader just sees single strings as the answer. You can do more complicated things though, like the following.\n\n\nanswer1 = (\n    {'expect': 'zebra', 'grade_decimal': 1},\n    {'expect': 'horse', 'grade_decimal': 0.45},\n    {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'Unicorn? Really?'}\n)\nanswer2 = (\n    {'expect': 'cat', 'grade_decimal': 1},\n    {'expect': 'feline', 'grade_decimal': 0.5}\n)\ngrader = ListGrader(\n    answers=[answer1, answer2],\n    subgraders=StringGrader()\n)\n\n\n\n\nIn this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while \ncat\n and \nunicorn\n will get the unicorn message (and 1/2 points), \nzebra\n and \nunicorn\n will not (and also get 1/2 points).\n\n\nOrdered Input\n # \n\n\nBy default, the ListGrader doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set ordered to True.\n\n\ngrader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader(),\n    ordered=True\n)\n\n\n\n\nNow, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none.\n\n\nMultiple Graders\n # \n\n\nIf you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set ordered to True when using a list of subgraders.\n\n\ngrader = ListGrader(\n    answers=['cat', 'x^2+1'],\n    subgraders=[StringGrader(), FormulaGrader(variables=[\nx\n])],\n    ordered=True\n)\n\n\n\n\nSingleListGraders in ListGrader\n # \n\n\nSome questions will require nested list graders. Simple versions can make use of a \nSingleListGrader\n subgrader, as in the following example.\n\n\nConsider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem.\n\n\ngrader = ListGrader(\n    answers=[\n        ['2', '4'],\n        ['1', '3']\n    ],\n    subgraders=SingleListGrader(\n        subgrader=NumericalGrader()\n    ),\n    ordered=True\n)\n\n\n\n\nThe nested \nSingleListGrader\n will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3.\n\n\nGrouped Inputs\n # \n\n\nIf you find yourself wanting to nest ListGraders, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question.\n\n\ngrader = ListGrader(\n    answers=[\n        ['cat', '1'],\n        ['dog', '2'],\n        ['tiger', '3']\n    ],\n    subgraders=ListGrader(\n        subgraders=[StringGrader(), NumericalGrader()],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2, 3, 3]\n)\n\n\n\n\nIn this case, the second level of grader is receiving multiple inputs, and so itself needs to be a ListGrader. The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader (StringGrader and NumericalGrader) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the \nListGrader\n will find the optimal ordering of (animal, number) pairs.\n\n\nThe grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements.\n\n\nHere is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a \nListGrader\n for the first grouping, and a \nStringGrader\n for the second. Note that the first entry in answers is a list that is passed directly into the \nListGrader\n, while the second entry is just a string. This second-level \nListGrader\n is unordered.\n\n\ngrader = ListGrader(\n    answers=[\n        ['bat', 'ghost', 'pumpkin'],\n        'Halloween'\n    ],\n    subgraders=[\n        ListGrader(\n            subgraders=StringGrader()\n        ),\n        StringGrader()\n    ],\n    ordered=True,\n    grouping=[1, 1, 1, 2]\n)\n\n\n\n\nOur last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them.\n\n\ngrader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            SingleListGrader(\n                subgrader=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2]\n)\n\n\n\n\nThis example has four input boxes, with the first and third being graded by a \nNumericalGrader\n, and the second and fourth being graded by a \nSingleListGrader\n.\n\n\nIt is possible to specify a grouping on a nested \nListGrader\n. The outer \nListGrader\n must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components.\n\n\ngrader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            ListGrader(\n                subgraders=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True,\n        grouping=[1, 2, 2]\n    ),\n    grouping=[1, 1, 1, 2, 2, 2]\n)\n\n\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to a \nListGrader\n.\n\n\ngrader = ListGrader(\n    answers=list,\n    subgraders=AbstractGrader or list of AbstractGraders,\n    ordered=bool, (default False)\n    grouping=list\n)", 
            "title": "ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#listgrader", 
            "text": "A  ListGrader  is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast,  SingleListGrader  can be used to grade a list of items entered all at once into a single answer box.) ListGraders work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student.", 
            "title": "ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#basic-usage", 
            "text": "In this example, each input is checked against the corresponding answer, using  StringGrader  as the subgrader.  grader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader()\n)  Each element of answers is set as an answer that is passed as the answers key into the subgrader. This should be set up as two input boxes that the student types in.  In the above example, the item grader just sees single strings as the answer. You can do more complicated things though, like the following.  answer1 = (\n    {'expect': 'zebra', 'grade_decimal': 1},\n    {'expect': 'horse', 'grade_decimal': 0.45},\n    {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'Unicorn? Really?'}\n)\nanswer2 = (\n    {'expect': 'cat', 'grade_decimal': 1},\n    {'expect': 'feline', 'grade_decimal': 0.5}\n)\ngrader = ListGrader(\n    answers=[answer1, answer2],\n    subgraders=StringGrader()\n)  In this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while  cat  and  unicorn  will get the unicorn message (and 1/2 points),  zebra  and  unicorn  will not (and also get 1/2 points).", 
            "title": "Basic usage"
        }, 
        {
            "location": "/grading_lists/list_grader/#ordered-input", 
            "text": "By default, the ListGrader doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set ordered to True.  grader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader(),\n    ordered=True\n)  Now, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none.", 
            "title": "Ordered Input"
        }, 
        {
            "location": "/grading_lists/list_grader/#multiple-graders", 
            "text": "If you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set ordered to True when using a list of subgraders.  grader = ListGrader(\n    answers=['cat', 'x^2+1'],\n    subgraders=[StringGrader(), FormulaGrader(variables=[ x ])],\n    ordered=True\n)", 
            "title": "Multiple Graders"
        }, 
        {
            "location": "/grading_lists/list_grader/#singlelistgraders-in-listgrader", 
            "text": "Some questions will require nested list graders. Simple versions can make use of a  SingleListGrader  subgrader, as in the following example.  Consider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem.  grader = ListGrader(\n    answers=[\n        ['2', '4'],\n        ['1', '3']\n    ],\n    subgraders=SingleListGrader(\n        subgrader=NumericalGrader()\n    ),\n    ordered=True\n)  The nested  SingleListGrader  will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3.", 
            "title": "SingleListGraders in ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#grouped-inputs", 
            "text": "If you find yourself wanting to nest ListGraders, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question.  grader = ListGrader(\n    answers=[\n        ['cat', '1'],\n        ['dog', '2'],\n        ['tiger', '3']\n    ],\n    subgraders=ListGrader(\n        subgraders=[StringGrader(), NumericalGrader()],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2, 3, 3]\n)  In this case, the second level of grader is receiving multiple inputs, and so itself needs to be a ListGrader. The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader (StringGrader and NumericalGrader) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the  ListGrader  will find the optimal ordering of (animal, number) pairs.  The grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements.  Here is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a  ListGrader  for the first grouping, and a  StringGrader  for the second. Note that the first entry in answers is a list that is passed directly into the  ListGrader , while the second entry is just a string. This second-level  ListGrader  is unordered.  grader = ListGrader(\n    answers=[\n        ['bat', 'ghost', 'pumpkin'],\n        'Halloween'\n    ],\n    subgraders=[\n        ListGrader(\n            subgraders=StringGrader()\n        ),\n        StringGrader()\n    ],\n    ordered=True,\n    grouping=[1, 1, 1, 2]\n)  Our last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them.  grader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            SingleListGrader(\n                subgrader=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2]\n)  This example has four input boxes, with the first and third being graded by a  NumericalGrader , and the second and fourth being graded by a  SingleListGrader .  It is possible to specify a grouping on a nested  ListGrader . The outer  ListGrader  must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components.  grader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            ListGrader(\n                subgraders=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True,\n        grouping=[1, 2, 2]\n    ),\n    grouping=[1, 1, 1, 2, 2, 2]\n)", 
            "title": "Grouped Inputs"
        }, 
        {
            "location": "/grading_lists/list_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  ListGrader .  grader = ListGrader(\n    answers=list,\n    subgraders=AbstractGrader or list of AbstractGraders,\n    ordered=bool, (default False)\n    grouping=list\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/grading_lists/single_list_grader/", 
            "text": "SingleListGrader\n # \n\n\nIf you want a response to be a delimiter-separated list of items, you can use a special ItemGrader called \nSingleListGrader\n to perform the grading. You need to specify a subgrader (which must be an ItemGrader, and could even be another SingleListGrader) to evaluate each individual item. The basic usage is as follows.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader()\n)\n\n\n\n\nTo receive full points for this problem, a student would enter \ncat, dog\n or \ndog, cat\n into the input box. Entering \ncat, octopus\n or just \ncat\n will receive half points.\n\n\nYou can use a tuple of lists to specify multiple lists of answers, just like normal ItemGraders.\n\n\ngrader = SingleListGrader(\n    answers=(\n        [('cat', 'feline'), 'dog'],\n        ['goat', 'vole'],\n    ),\n    subgrader=StringGrader()\n)\n\n\n\n\nNow, \ncat, dog\n and \ngoat, vole\n will get full grades. But mixes won't: \ncat, vole\n will score half credit.\n\n\nOrdered Input\n # \n\n\nBy default a SingleListGrader doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set \nordered=True\n.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    ordered=True\n)\n\n\n\n\nNow \ncat, dog\n will receive full grades, but \ndog, cat\n will be marked wrong. Note that \ncat\n will receive half credit, but \ndog\n will receive zero, as dog is incorrect in the first position. Ordered is false by default.\n\n\nLength Checking\n # \n\n\nIf students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    length_error=True\n)\n\n\n\n\nIf you give this \ncat\n, it will tell you that you've got the wrong length, and won't use up an attempt.\n\n\nLength_error is false by default. If you set length_error to True, then all answers in a tuple of lists (rather than a single answer list) must have the same length.\n\n\nChoosing Delimiters\n # \n\n\nYou can use whatever delimiter you like. The default is a comma (\n,\n). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    delimiter=';'\n)\n\n\n\n\nBy using different delimiters, it is possible to nest SingleListGraders:\n\n\ngrader = SingleListGrader(\n    answers=[['a', 'b'], ['c', 'd']],\n    subgrader=SingleListGrader(\n        subgrader=StringGrader()\n    ),\n    delimiter=';'\n)\n\n\n\n\nHere the expected student input is \na, b; c, d\n. It will also take \nb, a; d, c\n or \nc, d; a, b\n due to the unordered nature of both lists. However, \na, c; d, b\n is only worth half points.\n\n\nTurning Partial Credit Off\n # \n\n\nBy default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set partial_credit to False. It is True by default.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    partial_credit=False\n)\n\n\n\n\nNow \ncat, octopus\n will receive a grade of zero.\n\n\nMessages\n # \n\n\nMessages from the individual items are all concatenated together and presented to the student. It is also possible to have a \nwrong_msg\n on the \nSingleListGrader\n, which is presented to the student if the score is zero and there are no other messages, just like on an \nItemGrader\n.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    wrong_msg='Try again!'\n)\n\n\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to a \nSingleListGrader\n.\n\n\ngrader = SingleListGrader(\n    answers=list or tuple of lists,\n    subgrader=ItemGrader(),\n    partial_credit=bool (default True),\n    ordered=bool (default False),\n    length_error=bool (default False),\n    delimiter=string (default ',')\n)", 
            "title": "SingleListGrader"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#singlelistgrader", 
            "text": "If you want a response to be a delimiter-separated list of items, you can use a special ItemGrader called  SingleListGrader  to perform the grading. You need to specify a subgrader (which must be an ItemGrader, and could even be another SingleListGrader) to evaluate each individual item. The basic usage is as follows.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader()\n)  To receive full points for this problem, a student would enter  cat, dog  or  dog, cat  into the input box. Entering  cat, octopus  or just  cat  will receive half points.  You can use a tuple of lists to specify multiple lists of answers, just like normal ItemGraders.  grader = SingleListGrader(\n    answers=(\n        [('cat', 'feline'), 'dog'],\n        ['goat', 'vole'],\n    ),\n    subgrader=StringGrader()\n)  Now,  cat, dog  and  goat, vole  will get full grades. But mixes won't:  cat, vole  will score half credit.", 
            "title": "SingleListGrader"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#ordered-input", 
            "text": "By default a SingleListGrader doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set  ordered=True .  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    ordered=True\n)  Now  cat, dog  will receive full grades, but  dog, cat  will be marked wrong. Note that  cat  will receive half credit, but  dog  will receive zero, as dog is incorrect in the first position. Ordered is false by default.", 
            "title": "Ordered Input"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#length-checking", 
            "text": "If students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    length_error=True\n)  If you give this  cat , it will tell you that you've got the wrong length, and won't use up an attempt.  Length_error is false by default. If you set length_error to True, then all answers in a tuple of lists (rather than a single answer list) must have the same length.", 
            "title": "Length Checking"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#choosing-delimiters", 
            "text": "You can use whatever delimiter you like. The default is a comma ( , ). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    delimiter=';'\n)  By using different delimiters, it is possible to nest SingleListGraders:  grader = SingleListGrader(\n    answers=[['a', 'b'], ['c', 'd']],\n    subgrader=SingleListGrader(\n        subgrader=StringGrader()\n    ),\n    delimiter=';'\n)  Here the expected student input is  a, b; c, d . It will also take  b, a; d, c  or  c, d; a, b  due to the unordered nature of both lists. However,  a, c; d, b  is only worth half points.", 
            "title": "Choosing Delimiters"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#turning-partial-credit-off", 
            "text": "By default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set partial_credit to False. It is True by default.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    partial_credit=False\n)  Now  cat, octopus  will receive a grade of zero.", 
            "title": "Turning Partial Credit Off"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#messages", 
            "text": "Messages from the individual items are all concatenated together and presented to the student. It is also possible to have a  wrong_msg  on the  SingleListGrader , which is presented to the student if the score is zero and there are no other messages, just like on an  ItemGrader .  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    wrong_msg='Try again!'\n)", 
            "title": "Messages"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  SingleListGrader .  grader = SingleListGrader(\n    answers=list or tuple of lists,\n    subgrader=ItemGrader(),\n    partial_credit=bool (default True),\n    ordered=bool (default False),\n    length_error=bool (default False),\n    delimiter=string (default ',')\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/changelog/", 
            "text": "Change Log\n # \n\n\nVersion 1.1.x\n # \n\n\nVersion 1.1.2\n # \n\n\n\n\nThis version includes an internal change to the way that errors are handled during check.\n\n\nIf you only use builtin graders (FormulaGrader, ListGrader...) or public plugins (IntegralGrader) you should not notice any difference.\n\n\nIf you have previously written your own grading class, this change could affect what errors messages are displayed to students. In particular, only exceptions inheriting from \nMITxError\n will display their messages to students; other errors will be replaced with a generic error message.\n\n\n\n\nVersion 1.1.1\n # \n\n\n\n\nAdded AsciiMath renderer definitions\n\n\nWe now check for naming collisions in your configuration\n\n\nCleaned up voluptuous incorporation\n\n\nExtend domain of factorial function to all complex, except negative integers\n\n\nRemoved .pyc files from the zip file\n\n\nMinor bug fixes\n\n\n\n\nVersion 1.1.0\n # \n\n\n\n\nAdded numbered variables to FormulaGrader\n\n\n\n\nRemoved case-insensitive comparisons from FormulaGrader and IntegralGrader.\n\n\n\n\nWarning\n\n\nThis is a departure from edX and is a breaking change for authors who used case-insensitive FormulaGraders. However:\n\n\n\n\nCase-sensitive has always been the default for FormulaGrader and we are not aware of authors using case-insensitive FormulaGraders.\n\n\nPedagogically, we believe that students should think of \nM\n and \nm\n are different variables.\n\n\nRemoving case-insensitive comparison fixes a number of ambiguous situations.\n\n\n\n\n\n\n\n\n\n\nVersion 1.0.x\n # \n\n\nVersion 1.0.5\n # \n\n\n\n\nImproved debugging information for FormulaGrader\n\n\nFormulaGrader and IntegralGrader perform whitelist, blacklist, and forbidden_string checks after determining answer correctness. Incorrect answers using forbidden strings / functions are now marked incorrect, while correct answers using forbidden strings / functions raise errors.\n\n\nMinor improvements to existing unit tests\n\n\n\n\nVersion 1.0.4\n # \n\n\n\n\nAuthors can now specify a custom comparer function for FormulaGrader\n\n\nIntegralGrader now handles complex integrands, and gives meaningful error messages\n  for complex limits.\n\n\nMiscellaneous bug fixes for tensor variable name parsing\n\n\n\n\nVersion 1.0.3\n # \n\n\n\n\nAdded tensor variable names\n\n\n\n\nVersion 1.0.2\n # \n\n\n\n\nAdded error messages for overflow, division-by-zero, and out-of-domain errors in formulas\n\n\nAdded tests to reach 100% coverage\n\n\nRemoved redundant code\n\n\nFixed some bugs in unused code\n\n\n\n\nVersion 1.0.1\n # \n\n\n\n\nAdded DependentSampler\n\n\nFixed issue with zip file tests\n\n\nAdded doctests to test suite\n\n\nFixed bug in FormulaGrader when given an empty string", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#change-log", 
            "text": "", 
            "title": "Change Log"
        }, 
        {
            "location": "/changelog/#version-11x", 
            "text": "", 
            "title": "Version 1.1.x"
        }, 
        {
            "location": "/changelog/#version-112", 
            "text": "This version includes an internal change to the way that errors are handled during check.  If you only use builtin graders (FormulaGrader, ListGrader...) or public plugins (IntegralGrader) you should not notice any difference.  If you have previously written your own grading class, this change could affect what errors messages are displayed to students. In particular, only exceptions inheriting from  MITxError  will display their messages to students; other errors will be replaced with a generic error message.", 
            "title": "Version 1.1.2"
        }, 
        {
            "location": "/changelog/#version-111", 
            "text": "Added AsciiMath renderer definitions  We now check for naming collisions in your configuration  Cleaned up voluptuous incorporation  Extend domain of factorial function to all complex, except negative integers  Removed .pyc files from the zip file  Minor bug fixes", 
            "title": "Version 1.1.1"
        }, 
        {
            "location": "/changelog/#version-110", 
            "text": "Added numbered variables to FormulaGrader   Removed case-insensitive comparisons from FormulaGrader and IntegralGrader.   Warning  This is a departure from edX and is a breaking change for authors who used case-insensitive FormulaGraders. However:   Case-sensitive has always been the default for FormulaGrader and we are not aware of authors using case-insensitive FormulaGraders.  Pedagogically, we believe that students should think of  M  and  m  are different variables.  Removing case-insensitive comparison fixes a number of ambiguous situations.", 
            "title": "Version 1.1.0"
        }, 
        {
            "location": "/changelog/#version-10x", 
            "text": "", 
            "title": "Version 1.0.x"
        }, 
        {
            "location": "/changelog/#version-105", 
            "text": "Improved debugging information for FormulaGrader  FormulaGrader and IntegralGrader perform whitelist, blacklist, and forbidden_string checks after determining answer correctness. Incorrect answers using forbidden strings / functions are now marked incorrect, while correct answers using forbidden strings / functions raise errors.  Minor improvements to existing unit tests", 
            "title": "Version 1.0.5"
        }, 
        {
            "location": "/changelog/#version-104", 
            "text": "Authors can now specify a custom comparer function for FormulaGrader  IntegralGrader now handles complex integrands, and gives meaningful error messages\n  for complex limits.  Miscellaneous bug fixes for tensor variable name parsing", 
            "title": "Version 1.0.4"
        }, 
        {
            "location": "/changelog/#version-103", 
            "text": "Added tensor variable names", 
            "title": "Version 1.0.3"
        }, 
        {
            "location": "/changelog/#version-102", 
            "text": "Added error messages for overflow, division-by-zero, and out-of-domain errors in formulas  Added tests to reach 100% coverage  Removed redundant code  Fixed some bugs in unused code", 
            "title": "Version 1.0.2"
        }, 
        {
            "location": "/changelog/#version-101", 
            "text": "Added DependentSampler  Fixed issue with zip file tests  Added doctests to test suite  Fixed bug in FormulaGrader when given an empty string", 
            "title": "Version 1.0.1"
        }
    ]
}